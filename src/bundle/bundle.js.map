{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/svelte/store/index.mjs","../stores.ts","../scripts/phonetics.js","../components/LexEntry.svelte","../components/Lexicon.svelte","../scripts/alphabetize.ts","../components/PhraseEntry.svelte","../components/VariantInput.svelte","../components/Phrasebook.svelte","../components/Phonology.svelte","../scripts/docs.js","../components/Documentation.svelte","../scripts/files.js","../components/File.svelte","../components/Settings.svelte","../App.svelte","../main.ts"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            else\n                this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'itemscope',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.55.1' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { writable } from 'svelte/store';\n// Initial states for all the global variables across the app\nexport let file_name = writable('Unnamed Language');\nexport let case_sensitive = writable(false);\nexport let ignore_diacritics = writable(true);\nexport let header_tags = writable('');\nexport let lexicon = writable({});\nexport let alphabet = writable('a b c d e f g h i j k l m n o p q r s t u v w x y z');\nexport let word_input = writable('');\nexport let word_pronunciation = writable('');\nexport let phrasebook = writable({});\nexport let phrase_input = writable('');\nexport let phrase_pronunciation = writable('');\nexport let phrase_description = writable('');\nexport let category_input = writable('');\nexport let selected_category = writable('');\nexport let variant_inputs = writable([]);\nexport let romanizations = writable({ 'th': 'θ' });\nexport let romans_input = writable('th > θ');\nexport let onsets = writable('');\nexport let medials = writable('');\nexport let codas = writable('');\nexport let vowels = writable('');\nexport let illegals = writable('');\nexport let Docs = writable();\nexport let theme = writable('styles/dark.css');\nexport let autosave = writable(true);\n","// TODO: The pronunciation rule format is going to be changed to the more standard `pattern/substitution/context` format. This whole function needs to be rewritten.\nimport { get } from 'svelte/store';\nimport { romanizations, romans_input, case_sensitive, lexicon, word_input, word_pronunciation,\n    phrasebook, phrase_input, phrase_pronunciation, onsets, medials, codas, vowels, illegals\n} from '../stores.js';\n\nexport function get_pronunciation(word) {\n    let $romanizations = get(romanizations);\n    let $case_sensitive = get(case_sensitive);\n    word = `^${word.replaceAll(/[^\\S\\n]|(\\n)/gm, '^$1')}^`; // add carets for front/end searching, treat spaces as word boundaries\n    word = $case_sensitive? word : word.toLowerCase(); // if the case-sensitive setting is ticked, don't force to lowercase.\n    // Romanizations need to be sorted by length and applied in that order.\n    // First, we need an array of all the differnt lengths of polygraphs which are used in the romanizations.\n    let lengths = [];\n    for (let rom in $romanizations) {\n        lengths.push(rom.length);\n    }\n    lengths = Array.from(new Set(lengths)).sort((a, b) => b - a); // descending order, unique. It just works.\n\n    // We then create a dictionary with all of these lengths as keys.\n    // For each length key, its value is set to a dictionary of romanizations, such that `sort` is formatted like\n    // {\n    //  1: { '1 character pattern': 'pronunciation', 'another 1 character pattern': 'pronunciation', ... },\n    //  2: { '2 character pattern': 'pronunciation', ... }\n    //  ...\n    // }\n    let sort = {};\n    for (let length of lengths) {\n        if (!(length in sort)) {\n            sort[length] = {};\n        }\n        for (let rom in $romanizations) {\n            if (rom.length === length) {\n                sort[length][rom] = $romanizations[rom];\n            }\n        }\n    }\n\n    /** \n     * Then we go through each length of pattern, checking for patterns from the starting point of each\n     * character in the word. Given the word 'dread' and the pattern 'ad', it would find a pattern match\n     * when i = 3 and the patterns length we're checking for is 2 (†1). We then find the pronunciation to\n     * substitute at this position (†2) and use slices to replace the pattern with the substitute (†3).\n     * We add the length of the substituion string to `i` so that the next iteration skips past the part of\n     * the word we have already changed (†4). When this process is done, we remove the carets (†5) and\n     * return the processed word. \n     */\n    for (let i = 0; i < word.length; i++) {\n        for (let length of lengths) {\n            let substring = word.slice(i, i + length);\n\n            let match = false;\n            Object.keys(sort[length]).forEach(pattern => {\n                let new_pattern = [...pattern]\n                    .map((char, i) => {\n                        return char === '_' && substring[i] !== '^'? substring[i] : char;\n                    })\n                    .join('');\n                if (new_pattern === substring) {\n                    match = [...sort[length][pattern]]\n                        .map((char, i) => {\n                            return char === '_' && substring[i] !== '^'? substring[i] : char;\n                        })\n                        .join('');\n                }\n            });\n\n            if (substring in sort[length] || match) { // †1\n                let substitute = match ? match : sort[length][substring]; // †2\n                word = word.slice(0, i) + substitute + word.slice(length + i); // †3\n                i += substitute.length - 1; // †4\n                break;\n            }\n        }\n    }\n    return word.replaceAll('^', ' ').trim().replaceAll('∅', ''); // (†5)\n}\n\n/**\n * Takes a list of rules and a dictionary of categories and returns a new list of rules\n * which have been permutated with every item from the categories for every rule that\n * contains a category symbol.\n * @param {Array} rules\n * @param {Object} categories\n * @returns {Array} The expanded rules array.\n */ //TODO: Like most of the arrays and dictionaries in this codebase, new interfaces should be created (TS migration).\nfunction generateRules(rules, categories) {\n    // This function was mostly generated by OpenAI's chatGPT @ https://chat.openai.com/chat.\n\n    // Initialize an empty array to store the expanded rules\n    let expandedRules = [];\n\n    // Iterate through each rule\n    for (let rule of rules) {\n        // Split the rule into pattern and substitution parts\n        let [pattern, substitution] = rule.split('>');\n\n        // Split the pattern and substitution into arrays of characters\n        pattern = pattern.split('');\n        substitution = substitution.split('');\n\n        // Create a new set of unique category symbols in the pattern\n        let uniqueCategorySymbols = [\n            ...new Set(pattern.filter(symbol => symbol in categories)),\n        ];\n\n        // Create all possible combinations of the unique category symbols.\n        let combinations = uniqueCategorySymbols.reduce(\n            (combos, symbol) => {\n                let newCombos = [];\n                for (let combo of combos) {\n                    for (let item of categories[symbol]) {\n                        newCombos.push(combo.concat(item));\n                    }\n                }\n                return newCombos;\n            },\n            [[]]\n        );\n\n        // Iterate through the combinations of symbols\n        for (let combo of combinations) {\n            let newPattern = [...pattern];\n            let expandedSubstitution = [...substitution];\n\n            // Replace the category symbols in the pattern and substitution with the corresponding symbol in the combination\n            for (let i = 0; i < uniqueCategorySymbols.length; i++) {\n                newPattern = newPattern.map(symbol =>\n                    symbol === uniqueCategorySymbols[i] ? combo[i] : symbol\n                );\n            }\n\n            // GPT couldn't figure out how to do this block. Have to do this myself. If there are bugs, they're probably here.\n            expandedSubstitution = expandedSubstitution.map((symbol, index) => {\n                if (uniqueCategorySymbols.includes(symbol)) {\n                    // symbol is in pattern\n                    return combo[uniqueCategorySymbols.indexOf(symbol)];\n                } else if (symbol in categories) {\n                    // symbol is not in pattern\n                    return categories[symbol][\n                        categories[[...pattern][index]].indexOf(\n                            newPattern[index]\n                        )\n                    ];\n                } else {\n                    return symbol;\n                } // symbol is not a category\n            });\n\n            // generate the new rule by joining pattern and substitution and push into expandedRules\n            let expandedRule = `${newPattern.join('')}>${expandedSubstitution.join('')}`;\n            // expandedRule = expandedRule.replaceAll('∅', ''); // get rid of null signs // leave null signs, post-processor takes care of it\n            expandedRules.push(expandedRule);\n        }\n    }\n    // Return the expanded rules array\n    return expandedRules;\n}\n\n/**\n * Updates the romanizations object with the new rules. Uses {@link generateRules}\n * to deal with category symbol parsing. It updates the pronunciations of all\n * entries in the lexicon and phrasebook, provided they are not marked as\n * irregular.\n */\nexport function writeRomans () {\n    let $romanizations = {};\n    let categories = {};\n    let rules = [];\n\n    // On a first pass of the input directly in the textarea,\n    // we parse out the category definitions and rom rules.\n    let txt = get(romans_input);\n    txt.split('\\n').forEach(line => {\n        // Parse each new line as a rule\n        // remove all white space\n        let rule = line.trim().replace(/\\s+/g, '');\n        // if the rule contain `::`, it is a category\n        if (rule.includes('::')) {\n            let [symbol, items_string] = rule.split('::');\n            let items = items_string.split(',');\n            categories[symbol] = items;\n        }\n        // if the rule contain `>`, it is a rom rule\n        if (rule.includes('>')) {\n            rules.push(rule);\n        }\n    });\n\n    // Then we let GPT solve all my problems.\n    let full_rule_set = generateRules(rules, categories);\n\n    // And now we just have to parse the rules to the romanizations dict.\n    full_rule_set.forEach(rule => {\n        let [pattern, substituion] = rule.split('>');\n        $romanizations[pattern] = substituion;\n    });\n\n    // The block below is used to update all the pronunciation values in the editors, lexicon, and phrasebook.\n    word_pronunciation.set(get_pronunciation(get(word_input)));\n    let $lexicon = get(lexicon);\n    for (let entry in $lexicon) {\n        if ($lexicon[entry][2] === false) {\n            // all non-irrelgular pronunciations\n            $lexicon[entry][0] = get_pronunciation(entry);\n        }\n    }\n    lexicon.set($lexicon);\n\n    phrase_pronunciation.set(get_pronunciation(get(phrase_input)));\n    let $phrasebook = get(phrasebook);\n    for (let category in phrasebook) {\n        for (let entry in phrasebook[category]) {\n            phrasebook[category][entry].pronunciation =\n                get_pronunciation(entry);\n            for (let variant in phrasebook[category][entry].variants) {\n                phrasebook[category][entry].variants[variant].pronunciation =\n                    get_pronunciation(variant);\n            }\n        }\n    }\n    phrasebook.set($phrasebook);\n\n    romanizations.set($romanizations);\n};\n\n/**\n * Attempts to complete a given word using the user's phonotactics.\n * @param {string} trial\n * @returns {string} The completed word, or an empty string if no word could be generated\n */\nexport function complete_word(trial) {\n    let random_boolean = () => Math.floor(Math.random() * 2) === 0;\n    let choice = arr => arr[Math.floor(Math.random() * arr.length)];\n    let inventory = {\n        Onsets: get(onsets).split(/\\s+/g),\n        Medials: get(medials).split(/\\s+/g), \n        Codas: get(codas).split(/\\s+/g),\n        Vowels: get(vowels).split(/\\s+/g),\n        Illegals: !!get(illegals)? get(illegals).split(/\\s+/g) : ['N/A']\n    }\n    let word = '^' + trial;\n\n    const finalize = (word) => {\n        word += '^'; // the string is in the format \"^word^\" so that \"^\" \n                    // may be be used as a character to mark the start/end of a word\n                   // in the user-defined illegal combinations\n        if (!inventory.Illegals.some(v => word.includes(v))) {\n            return word.replace(/\\^/g, '');\n        } else {\n            return '';\n        }\n    };\n\n    let ends_in_vowel = false;\n    for (let v of inventory.Vowels) {\n        // Check if word ends in vowel; add middle consonant and vowel, or coda and end\n        if (\n            word.includes(v) &&\n            word.lastIndexOf(v) === word.length - v.length\n        ) {\n            if (random_boolean()) {\n                word += choice(inventory.Medials) + choice(inventory.Vowels);\n                ends_in_vowel = true;\n                break;\n            } else {\n                word += choice(inventory.Codas);\n                return finalize(word);\n            }\n        }\n    }\n    if (!ends_in_vowel) {\n        // Add vowel to end of word, potentially end word with vowel or vowel + coda\n        word += choice(inventory.Vowels);\n        if (random_boolean()) {\n            if (random_boolean()) {\n                word += choice(inventory.Codas);\n            }\n            return finalize(word);\n        }\n    }\n    // End word with one of: coda, middle + vowel, or middle + vowel + coda\n    if (random_boolean()) {\n        word += choice(inventory.Codas);\n    } else {\n        word += choice(inventory.Medials) + choice(inventory.Vowels);\n        if (random_boolean()) {\n            word += choice(inventory.Codas);\n        }\n    }\n    return finalize(word);\n}\n\n/**\n * Generates a random word based on the given phonotactics. Will attempt\n * up to 50 times to generate a word that does not contain any illegal\n * combinations. If no word can be generated, returns an empty string.\n * @returns {string} The generated word, or an empty string if one could not be generated.\n */\nexport function generate_word() {\n    const attempt = () => {\n        let inventory = {\n            Onsets: get(onsets).split(/\\s+/g),\n            Medials: get(medials).split(/\\s+/g),\n            Codas: get(codas).split(/\\s+/g),\n            Vowels: get(vowels).split(/\\s+/g),\n            Illegals: !!get(illegals)? get(illegals).split(/\\s+/g) : ['N/A']\n        }\n        let random_boolean = () => Math.floor(Math.random() * 2) === 0;\n        let choice = arr => arr[Math.floor(Math.random() * arr.length)];\n        let word = '^';\n    \n        if (random_boolean()) {\n            word += choice(inventory.Vowels);\n        } else {\n            word += choice(inventory.Onsets);\n            word += choice(inventory.Vowels);\n        }\n    \n        for (let j = 0; j < 2; j++) {\n            if (random_boolean() || word.length === 2 /* word is \"^vowel\" */) {\n                word += choice(inventory.Medials);\n                word += choice(inventory.Vowels);\n            }\n        }\n        if (random_boolean()) {\n            word += choice(inventory.Codas);\n        }\n    \n        word += '^';\n        if (!inventory.Illegals.some(v => word.includes(v))) {\n            return word.replace(/\\^/g, '');\n        } else {\n            return '';\n        }\n    }\n    for (let i = 0; i < 50; i++) {\n        let word = attempt();\n        if (!!word) {\n            return word;\n        }\n    }\n    return '';\n}\n","<script lang=\"ts\">\n    import { lexicon } from '../stores.js';\n    import { createEventDispatcher } from 'svelte';\n    const dispatch = createEventDispatcher();\n    const edit = () => dispatch('edit')\n    export let entry = '';\n</script>\n<div id='{entry}' class=\"lex-entry prelined\" on:contextmenu={edit}>\n    <p  style=\"font-style: italic\">{entry}</p>\n    <p class='pronunciation'>{$lexicon[entry][0]}</p>\n    {#each $lexicon[entry][3] as tag}\n        <div class='tag-item'>{tag}</div>\n    {/each}\n    <p>{$lexicon[entry][1]}</p>\n</div>\n","<script lang=\"ts\">\n    import { lexicon, word_input, word_pronunciation, case_sensitive, alphabet, ignore_diacritics } from '../stores.js';\n    import { alphabetize } from '../scripts/alphabetize.js';\n    import { get_pronunciation } from '../scripts/phonetics.js';\n    import LexEntry from './LexEntry.svelte';\n    let def_input = ''; let tags_input = '';\n    let search_words = ''; let search_definitions = ''; let search_tags = '';\n    $: keys = [];\n    $: filtered_lex = keys.reduce((acc, key) => {\n        if (key in $lexicon) acc[key] = $lexicon[key];\n        return acc;\n    }, {});\n    let alphabetized;\n    // syntax below with IIFE is to trigger update to `alphabetized` on any change to either `$alphabet` or `keys`\n    $: $alphabet, keys, (() => { alphabetized = alphabetize(!!keys.length? filtered_lex : $lexicon) })(); \n    $: collapsedPanel = false;\n    /**\n     * This function is used to delete an entry from the lexicon and\n     * move it into the input fields for editing or deletion. If there\n     * is text in the input fields, it asks the user for overwrite\n     * confirmation. \n     * @param {string} word\n     */\n    function edit_entry (word) {\n        let confirmation = true;\n        if (!!$word_input || !!def_input) {\n            confirmation = confirm(\n                'There is text in the word entry fields. Are you sure you want to overwrite it?'\n            );\n        }\n        if (confirmation) {\n            $word_input = word;\n            $word_pronunciation = $lexicon[word][0];\n            def_input = $lexicon[word][1];\n            tags_input = $lexicon[word][3].join(' ');\n            delete $lexicon[word];\n            $lexicon = {...$lexicon}; // assignment trigger\n            console.log($lexicon);\n        }\n    }\n\n    /**\n     * This function is called when the user clicks the \"Add Word\" button.\n     * It takes the values from the word input, pronunciation input, definition\n     * input, and tags input fields, and adds them to the lexicon. If the word\n     * already exists and `append` is `true`, it appends the definition and tags\n     * to the existing entry. If `append` is `false`, it overwrites the existing\n     * entry. \n     * @param {bool} append\n     * @returns {string}\n     */\n    function add_word(append) {\n        let word = $word_input.trim()\n        if (!word) return;\n        let definition = def_input.trim()\n        if (!definition) return;\n        let pronunciation = $word_pronunciation.trim()\n        let tags;\n        if (!tags_input) {\n            tags = [];\n        } else {\n            tags = tags_input.trim().split(/\\s+/g);\n        }\n\n        if (!append) {\n            $lexicon[word] = [pronunciation, definition, pronunciation !== get_pronunciation(word), tags];\n        } else {\n            $lexicon[word][1] += '\\n' + definition;\n            $lexicon[word][3].push(...tags);\n        }\n        $lexicon = {...$lexicon}; // assignment trigger\n\n        // follow_lex_link(word);\n        $word_input = '';\n        $word_pronunciation = '';\n        def_input = '';\n        tags_input = '';\n        return word;\n    }\n\n    /**\n     * Searches the lexicon for a word, definition, or tag. \n     * The character '!' is used to require an exact match.\n     * The caret '^' can be used to represent the beginning\n     * or end of a word. Searches are combinative, and only\n     * results which match all search input fields will be\n     * selected as matches. \n     * It then calls {@link rewrite_entries} to display the results.\n     * @returns {any}\n     */\n    function search_lex() {\n        let words_search = $case_sensitive?  search_words.trim() : search_words.toLowerCase().trim();\n        let definitions_search = search_definitions.toLowerCase().trim();\n        let tags_search = search_tags.toLowerCase().trim()? search_tags.toLowerCase().trim().split(/\\s+/g) : [];\n        keys = [];\n        if (!!words_search || !!definitions_search || !!tags_search) {\n            // Turn l into a list of [search by word terms, search by def terms\n            let l = [[...words_search.split('|')], [...definitions_search.split('|')]];\n            for (let word in $lexicon) {\n                let w = `^${word}^`;\n                let match = true;\n                for (let a of l[0]) {\n                    // words\n                    if (!w.includes(a)) {\n                        match = false;\n                    }\n                }\n                for (let a of l[1]) {\n                    // definitions\n                    let needs_exact_match = a[0] === '!';\n                    if (needs_exact_match) {\n                        let pattern = new RegExp(`\\\\b${a.split('!')[1]}\\\\b`, 'i');\n                        if (!pattern.test($lexicon[word][1].toLowerCase())) { // exact word match\n                            match = false;\n                        }\n                    } else if (!$lexicon[word][1].toLowerCase().includes(a)) { // partial match\n                        match = false;\n                    }\n                }\n                if (!!$lexicon[word][3]) {\n                    // has at least one tag\n                    let partial_tag_match = false;\n                    let needs_exact_match = false;\n                    let has_exact_match = false;\n                    for (let tag of $lexicon[word][3]) {\n                        for (let a of tags_search) {\n                            // tags\n                            if (a[0] === '!') {\n                                needs_exact_match = true;\n                                if (`!${tag}` === a) {\n                                    has_exact_match = true;\n                                    partial_tag_match = true;\n                                }\n                            }\n                            if (`^${tag}^`.includes(a)) {\n                                partial_tag_match = true;\n                            }\n                        }\n                    }\n                    if ((!partial_tag_match && !!tags_search) || (needs_exact_match && !has_exact_match)) {\n                        match = false;\n                    }\n                } else {\n                    // has no tags\n                    if (!!tags_search) {\n                        match = false; // at least one tag as search term\n                    }\n                }\n                if (match) {\n                    keys = [...keys, word];\n                }\n            }\n            if (!keys.length) keys = [null]; // Search was attempted, no results\n        }\n    }\n</script>\n<!-- Lexicon Tab -->\n<div class='tab-pane'>\n    <!-- Header -->\n    <div class='container row text-center header'>\n        <div class=\"narrow-col\">\n            <label for=\"case-sensitive\" style=\"margin: auto;\">Case Sensitivity</label>\n            <input type=\"checkbox\" style=\"width: 15px; margin: auto;\" id=\"case-sensitive\" bind:checked={$case_sensitive} />\n        </div>\n        <div class=\"narrow-col\">\n            <label for=\"ignore-diacritic\" style=\"margin: auto; text-align: right;\">Ignore Diacritics</label>\n            <input type=\"checkbox\" style=\"width: 15px; margin: auto;\" id=\"ignore-diacritic\" bind:checked={$ignore_diacritics}/>\n        </div>\n        <input id=\"alph-input\" type=\"text\" bind:value={$alphabet}>\n    </div>\n    <!-- Body -->\n    <div class='row' style=\"height: 84vh\">\n        <!-- Word Entry Side -->\n        <div class='container collapsible-column' style='height: 100%'>\n            <button class=\"collapser\" on:click={ () => collapsedPanel = !collapsedPanel }></button>\n            <div class:collapsed={collapsedPanel} class='text-center scrolled' style=\"height: 100%; overflow-x: hidden\">\n                <label for=\"wrd-input\">New Word</label>\n                <input id=\"wrd-input\" type=\"text\" bind:value={$word_input} on:input={() => $word_pronunciation = get_pronunciation($word_input)}>\n                <input id=\"pronunciation\" class=\"pronunciation\" type=\"text\" bind:value={$word_pronunciation}>\n                <br>\n                <label for=\"def-input\">Definition</label>\n                <textarea name=\"Definition\" id=\"def-input\" rows=\"16\" bind:value={def_input}></textarea>\n                <br>\n                <label for=\"tags\">Tags</label>\n                <textarea id=\"tags\" rows=\"1\" bind:value={tags_input}></textarea>\n                <br>\n                {#if !($word_input in $lexicon)}\n                    <button class=\"hover-highlight hover-shadow\" id=\"add-word-button\" on:click={() => add_word(false)}>Add Word</button>\n                {:else}\n                    <div class=\"row\" id=\"definition-exists\">\n                        <button id=\"overwrite\" class=\"hover-shadow\" on:click={() => add_word(false)}>Overwrite Entry</button>\n                        <button id=\"append\" class=\"hover-shadow hover-highlight\" on:click={() => add_word(true)}>Append Definition</button>\n                    </div>\n                {/if}\n                <div style=\"width: 100vw\"></div>\n            </div>\n        </div>\n        \n        <!-- Lexicon -->\n        <div class='container column text-center' style=\"height: 100%\">\n            <div class='row'>\n                <div class=\"column search-container\">\n                    {#if !search_words}\n                            <label for=\"search-wrd\" style=\"position: absolute; top: 0.5em; left: 1em\">Search by word…</label>\n                    {/if}\n                    <input id=\"search-wrd\" type=\"text\" class=\"search\" bind:value={search_words} on:input={search_lex}/>\n                </div>\n                <div class=\"column search-container\">\n                    {#if !search_tags}\n                            <label for=\"search-tag\" style=\"position: absolute; top: 0.5em; left: 1em\">Search by tags…</label>\n                    {/if}\n                    <input id=\"search-tag\" type=\"text\" class=\"search\" bind:value={search_tags} on:input={search_lex}/>\n                </div>\n            </div>\n            <div class=\"search-container\">\n                {#if !search_definitions}\n                    <label for=\"search-def\" style=\"position: absolute; top: 0.33em; left: 1em\">Search definitions…</label>\n                {/if}\n                <input id=\"search-def\" type=\"text\" class=\"search\" bind:value={search_definitions} on:input={search_lex}/>\n            </div>\n            <div class='scrolled' style=\"height: 88%\">\n                {#each alphabetized as word}\n                    <LexEntry entry={word} on:edit={() => edit_entry(word)}/>\n                {:else}\n                    <p class=\"info\" id=\"lex-body\">Add new words on the left</p>\n                {/each}\n            </div>\n            <p id=\"entry-counter\">\n                {#if !!keys} <!-- if there is a search being attempted -->\n                    {!!keys[0]? keys.length : '0'} {(keys.length === 1 && !!keys[0])? 'Match' : 'Matches'}\n                {:else} <!-- if there is no search being attempted -->\n                    {Object.keys($lexicon).length} {Object.keys($lexicon).length === 1? 'Entry' : 'Entries'}\n                {/if}\n            </p>\n        </div>\n    </div>\n</div>\n","import { get } from 'svelte/store';\nimport { case_sensitive, ignore_diacritics, alphabet, header_tags } from '../stores.js';\nexport function alphabetize(lexicon) {\n    let priority_tags = get(header_tags).toLowerCase().trim().split(/\\s+/);\n    let $alphabet = get(alphabet);\n    let $ignore_diacritics = get(ignore_diacritics);\n    let $case_sensitive = get(case_sensitive);\n    let all_words = structuredClone(lexicon);\n    let tag_ordered_lexes = [];\n    for (let tag of priority_tags) {\n        tag_ordered_lexes.push([]);\n        for (let word in all_words) {\n            if (lexicon[word][3].includes(tag)) {\n                tag_ordered_lexes[tag_ordered_lexes.length - 1].push(word);\n            }\n        }\n        for (let w of tag_ordered_lexes[tag_ordered_lexes.length - 1]) {\n            delete all_words[w];\n        }\n    }\n    let remaining_words = [];\n    for (let w in all_words) {\n        remaining_words.push(w);\n    }\n    tag_ordered_lexes.push(remaining_words);\n    // Lowercase alphabet if case-sensitivity is unticked\n    $alphabet = $case_sensitive ? $alphabet.trim() : $alphabet.trim().toLowerCase();\n    let order = $alphabet.split(/\\s+/);\n    // to make sure we find the largest tokens first, i.e. for cases where 'st' comes before 'str' alphabetically\n    let find_in_order = Array.from(new Set(order)).sort((a, b) => b.length - a.length); // descending, ensures uniqueness\n    let final_sort = [];\n    for (let group of tag_ordered_lexes) {\n        let lex = {};\n        let list = [];\n        for (let word of group) {\n            // case sensitivity\n            let w = $case_sensitive ? word : word.toLowerCase();\n            // diacritic sensitivity\n            w = $ignore_diacritics ? w.normalize('NFD').replace(/\\p{Diacritic}/gu, '') : w;\n            for (let token of find_in_order) {\n                w = w.replace(new RegExp(`${token}`, 'g'), `${order.indexOf(token)}.`);\n            }\n            let append = w.split('.');\n            for (let i of append) {\n                append[append.indexOf(i)] = +i || 0;\n            }\n            lex[word] = append;\n            list.push(append);\n        }\n        list.sort((a, b) => {\n            for (let i of a) {\n                let j = b[a.indexOf(i)];\n                if (i === j) {\n                    continue;\n                }\n                return i - j;\n            }\n            return 0;\n        });\n        let sorted = [];\n        for (let key in lex) {\n            sorted.push([key, list.indexOf(lex[key])]);\n        } // [ [word, index], [word, index], ...]\n        sorted.sort((a, b) => a[1] - b[1]);\n        for (let i = 0; i < sorted.length; i++) {\n            sorted[i] = sorted[i][0];\n        }\n        for (let i of sorted) {\n            final_sort.push(i);\n        }\n    }\n    return final_sort;\n}\n","<script lang=\"ts\">\n    import { phrasebook, selected_category } from '../stores.js';\n    import { createEventDispatcher } from 'svelte';\n    const dispatch = createEventDispatcher();\n    const edit = () => dispatch('edit')\n    export let phrase = '';\n</script>\n<div class=\"lex-entry\" id={phrase} on:contextmenu={edit}>\n    <p style=\"font-style: italic\">\n        {phrase}\n    </p>\n    <p class=\"pronunciation\">\n        {$phrasebook[$selected_category][phrase].pronunciation}\n    </p>\n    <p class=\"prelined\">\n        {$phrasebook[$selected_category][phrase].description}\n    </p>\n    {#if !!Object.keys($phrasebook[$selected_category][phrase].variants).length}\n        <p>⋲ ᴠᴀʀɪᴀɴᴛꜱ ⋺</p>\n        {#each Array(Math.ceil(Object.keys($phrasebook[$selected_category][phrase].variants).length / 3)) as _, i}\n            <div class=\"row\">\n                {#each Object.keys($phrasebook[$selected_category][phrase].variants).slice(i * 3, i * 3 + 3) as variant}\n                    <div class=\"column\">\n                        <p style=\"font-style: italic\">\n                            {variant}\n                        </p>\n                        <p class=\"pronunciation\">\n                            {$phrasebook[$selected_category][phrase].variants[variant].pronunciation}\n                        </p>\n                        <p class=\"prelined\">\n                            {$phrasebook[$selected_category][phrase].variants[variant].description}\n                        </p>\n                    </div>\n                {/each}\n            </div>\n        {/each}\n    {/if}\n</div>\n","<script lang='ts'>\n    import { createEventDispatcher } from 'svelte';\n\n    export let phrase = '';\n    export let pronunciation = '';\n    export let description = '';\n\n    const dispatch = createEventDispatcher();\n    const update = () => dispatch('update');\n</script>\n\n<div class=\"variant-div\">\n    <input type=\"text\" on:keyup={update} bind:value={phrase}/>\n    <input type=\"text\" class=\"pronunciation\" bind:value={pronunciation}>\n    <textarea bind:value={description}></textarea>\n    <br>\n</div>\n","<script lang=\"ts\">\n    import { phrasebook, phrase_input, phrase_description, phrase_pronunciation, \n        selected_category, category_input, variant_inputs } from \"../stores\";\n    import { get_pronunciation } from \"../scripts/phonetics\";\n    import PhraseEntry from \"./PhraseEntry.svelte\";\n    import VariantInput from \"./VariantInput.svelte\";\n    $category_input = $selected_category;\n    let search_phrase = '';\n    let search_description = '';\n    let phrase_keys = [];\n    $: collapsedPanel = false;\n\n    /**\n     * Searches the phrasebook within the currently selected category\n     * for entries matching the search terms. Phrases which contain only\n     * a match in one of their variants are also included.\n     * @returns {Array} An array of keys matching the search terms.\n     */ \n    function search_book() {\n        if (!$selected_category) return [];\n        let scope = $phrasebook[$selected_category];\n        let phrase_search = search_phrase.trim();\n        let descript_search = search_description.toLowerCase().trim();\n        if (!phrase_search && !descript_search) return Object.keys(scope);\n\n        let keys = [];\n        for (let entry in scope) {\n            let term = '^' + entry + '^';\n            let phrase_match = !phrase_search\n            let descript_match = !descript_search\n\n            if (term.includes(phrase_search))\n                phrase_match = true;\n            if (scope[entry].description.toLowerCase().includes(descript_search)) \n                descript_match = true;\n\n            for (let variant in scope[entry].variants) {\n                let v_term = '^' + variant + '^';\n                if (v_term.includes(phrase_search))\n                    phrase_match = true;\n                if (scope[entry].variants[variant].description .toLowerCase().includes(descript_search))\n                    descript_match = true;\n            }\n\n            if (phrase_match && descript_match) \n                keys.push(entry);\n        }\n        return keys;\n    }\n    // any time $selected_category, search_phrase, or search_description changes, update phrase_keys\n    $: $selected_category, search_phrase, search_description, (() => {phrase_keys = search_book()})(); \n\n    /**\n     * Changes the selected category and updates the category input field.\n     * @param {string} category\n     */\n    function select(category) {\n        $selected_category = category;\n        $category_input = category;\n    }\n\n    /**\n     * Removes a phrase from the phrasebook and moves it to the input fields, including all variants.\n     * @param {string} phrase\n     */ \n    function edit_phrase(phrase) {\n        $phrase_input = phrase;\n        $phrase_pronunciation = $phrasebook[$selected_category][phrase].pronunciation;\n        $phrase_description = $phrasebook[$selected_category][phrase].description;\n        $variant_inputs = [];\n        for (let variant in $phrasebook[$selected_category][phrase].variants) {\n            $variant_inputs = [...$variant_inputs, {\n                phrase: variant,\n                pronunciation: $phrasebook[$selected_category][phrase].variants[variant].pronunciation,\n                description: $phrasebook[$selected_category][phrase].variants[variant].description,\n            }];\n        }\n        delete $phrasebook[$selected_category][phrase]; $phrasebook = $phrasebook;\n    }\n    \n    /**\n     * Adds a new blank variant to the variant_inputs array.\n     */ \n    function add_variant() {\n        $variant_inputs = [...$variant_inputs, {\n            phrase: '',\n            pronunciation: '',\n            description: '',\n        }];\n    }\n\n    /**\n     * Adds a phrase from the input fields to the phrasebook, including all variants,\n     * and clears the input fields.\n     */ \n    function add_phrase() {\n        let new_phrase = $phrase_input.trim();\n        if (!new_phrase) return;\n        let description = $phrase_description.trim();\n        if (!description) return;\n        let category = $category_input.trim();\n        if (!category) return;\n        let pronunciation = $phrase_pronunciation.trim();\n\n        if (!!$phrasebook[category][new_phrase]) {\n            let confirmation = window.confirm(\n                'This phrase already exists in this category. Are you sure you want to overwrite it?'\n            );\n            if (!confirmation) return;\n        }\n\n        $phrasebook[category][new_phrase] = {\n            pronunciation: pronunciation,\n            description: description,\n            variants: {},\n        };\n        for (let variant of $variant_inputs) {\n            let phrase = variant.phrase.trim();\n            if (!phrase) continue;\n            let description = variant.description.trim();\n            if (!description) continue;\n            let pronunciation = variant.pronunciation.trim();\n            $phrasebook[category][new_phrase].variants[phrase] = {\n                pronunciation: pronunciation,\n                description: description,\n            };\n        };\n\n        $phrasebook = $phrasebook;\n        $phrase_input = '';\n        $phrase_pronunciation = '';\n        $phrase_description = '';\n        $variant_inputs = [];\n        $selected_category = category;\n    }\n</script>\n<!-- Phrasebook Tab -->\n<div class=\"tab-pane\">\n    <div class=\"row\" style=\"height: 58vh;\">\n        <!-- Categories -->\n        <div class=\"container column\" style=\"max-width: 18%;\">\n            <p>Categories</p>\n            <hr />\n            <div class=\"column scrolled\" style=\"max-height: 90%;\" id=\"category-body\">\n                {#each Object.keys($phrasebook) as category}\n                    <div class=\"lex-entry capitalize\" class:selected={category === $selected_category} on:mousedown={() => select(category)}>\n                            {category}\n                    </div>\n                {:else}\n                    <p class=\"info\">Categories will appear here.</p>\n                {/each}\n            </div>\n        </div>\n        <div class=\"container column\">\n            <!-- Search Fields -->\n            <div class=\"row\">\n                <div class=\"column search-container\">\n                    {#if !search_phrase}\n                         <label for=\"search-phrase\" style=\"position: absolute; top: .5em; left: 1em\">Search by phrase…</label>\n                    {/if}\n                    <input id=\"search-phrase\" type=\"text\" class=\"search\" bind:value={search_phrase}/>\n                </div>\n                <div class=\"column search-container\">\n                    {#if !search_description}\n                        <label for=\"search-description\" style=\"position: absolute; top: .5em; left: 1em\">Search descriptions…</label>\n                    {/if}\n                    <input id=\"search-description\" type=\"text\" class=\"search\" bind:value={search_description}/>\n                </div>\n            </div>\n            <!-- Book -->\n            <div class=\"column scrolled\" id=\"phrasebook-body\" style=\"max-height: 90%;\">\n                {#if !!Object.keys($phrasebook).length}\n                    {#each phrase_keys as phrase}\n                        <PhraseEntry phrase={phrase} on:edit={() => edit_phrase(phrase)} />\n                    {/each}\n                {:else}\n                    <p class=\"info\">Select a category from the left or add your first phrase entry.</p>\n                {/if}\n            </div>\n        </div>\n    </div>\n    <!-- Phrase Editor -->\n    <div class=\"container collapsible-row\" style=\"height: 34vh;\">\n        <div class=\"row\" style=\"width: 100vh\">\n            <button class=\"collapser-h\" on:click={() => collapsedPanel = !collapsedPanel}></button>\n        </div>\n        <div class=\"row\" class:collapsed={collapsedPanel} style=\"height: 92%\">\n            <div class=\"column scrolled\" style=\"max-height: 100%\">\n                <label for=\"phrase\">Phrase</label>\n                <input type=\"text\" bind:value={$phrase_input} on:input={() => $phrase_pronunciation = get_pronunciation($phrase_input)} />\n                <input type=\"text\" class=\"pronunciation\" bind:value={$phrase_pronunciation} />\n                <label for=\"description\">Description</label>\n                <textarea id=\"description\" bind:value={$phrase_description}></textarea>\n                <br>\n                <label for=\"category\">Category</label>\n                <input type=\"text\" bind:value={$category_input} />\n                <button on:click={add_phrase} class=\"hover-shadow hover-highlight\">Add Phrase</button>\n            </div>\n            <div class=\"column scrolled\" style=\"max-height: 100%\" id=\"variants-body\">\n                {#each $variant_inputs as _, i}\n                    <VariantInput \n                        bind:phrase={$variant_inputs[i].phrase} \n                        bind:pronunciation={$variant_inputs[i].pronunciation}\n                        bind:description={$variant_inputs[i].description}\n                        on:update={() => $variant_inputs[i].pronunciation = get_pronunciation($variant_inputs[i].phrase)}\n                    />\n                {:else}\n                    <p class=\"info\">Click the button below to add a variation for this phrase</p>\n                {/each}\n                <button on:click={add_variant} class=\"hover-shadow hover-highlight\">+ Variant</button>\n            </div>\n        </div>\n    </div>\n</div>\n","<script lang=\"ts\">\n    import { romans_input, onsets, medials, codas, vowels, illegals } from \"../stores\";\n    import { get_pronunciation, writeRomans, complete_word, generate_word } from '../scripts/phonetics.js';\n    let trial = ''; let ortho_test = '';\n    $: trial_completion = complete_word(trial);\n    $: test_pronunciation = get_pronunciation(ortho_test);\n    $: generated_words = Array(24).fill('');\n</script>\n<!-- Phonology Tab -->\n<div class=\"tab-pane\">\n    <div class=\"row\" style=\"height: 92vh\">\n        <!-- Phonotactics -->\n        <div class=\"container column scrolled\" style=\"height: 100%\">\n            <label for=\"onsets\">Onset Consonants</label>\n            <textarea id=\"onsets\" class=\"phonology\" bind:value={$onsets}></textarea>\n            <br>\n            <label for=\"medials\">Medial Consonants</label>\n            <textarea id=\"medials\" class=\"phonology\" bind:value={$medials}></textarea>\n            <br>\n            <label for=\"codas\">Coda Consonants</label>\n            <textarea id=\"codas\" class=\"phonology\" bind:value={$codas}></textarea>\n            <br>\n            <label for=\"vowels\">Vowels</label>\n            <textarea id=\"vowels\" class=\"phonology\" bind:value={$vowels}></textarea>\n            <br>\n            <label for=\"illegals\">Illegal Combinations</label>\n            <textarea id=\"illegals\" class=\"phonology\" bind:value={$illegals}></textarea>\n            <br><br>\n            <label for=\"trial\">Trial Words</label>\n            <input type=\"text\" id=\"trial\" bind:value={trial}/>\n            <p style=\"font-family: Gentium\">{trial_completion}</p>\n            <br>\n            <button class=\"hover-highlight hover-shadow\" \n                on:click={() => generated_words = Array(24).fill(null).map(_ => generate_word())}\n                    >Generate Words</button>\n            {#each Array(generated_words.length/3).fill(null) as _, i}\n                <div class=\"row\">\n                    {#each generated_words.slice(i * 3, i * 3 + 3) as word}\n                        <div class=\"column\">\n                            <p class=\"prelined\" style=\"font-family: Gentium\">{word}</p>\n                        </div>\n                    {/each}\n                </div>\n            {/each}\n            <br>\n        </div>\n        <!-- Romanization -->\n        <div class=\"container column scrolled\" style=\"height: 100%\">\n            <label for=\"romans\">Pronunciations</label>\n            <textarea id=\"romans\" rows=\"30\" style=\"text-align: left\" class=\"prelined\" \n                bind:value={$romans_input} on:blur={writeRomans}></textarea>\n            <br><br>\n            <label for=\"test-romans\">Orthography Testing</label>\n            <textarea id=\"test-romans\" rows=\"4\" class=\"prelined\" bind:value={ortho_test}></textarea>\n            <textarea id=\"test-romans-result\" class=\"pronunciation\" readonly>{test_pronunciation}</textarea>\n        </div>\n    </div>\n</div>\n","import { Docs } from \"../stores\";\nimport { get } from \"svelte/store\";\nconst EditorJS = require('@editorjs/editorjs');\nconst Header = require('@editorjs/header');\nconst Paragraph = require('@editorjs/paragraph');\nconst Table = require('@editorjs/table');\nconst Underline = require('@editorjs/underline');\nclass Monospace { // EditorJS custom class\n    static get CSS() {\n        return 'cdx-monospace';\n    };\n    constructor({ api }) {\n        this.api = api;\n        this.button = null;\n        this.tag = 'CODE';\n        this.iconClasses = {\n            base: this.api.styles.inlineToolButton,\n            active: this.api.styles.inlineToolButtonActive,\n        };\n    }\n    static get isInline() {\n        return true;\n    }\n    render() {\n        this.button = document.createElement('button');\n        this.button.type = 'button';\n        this.button.textContent = 'M';\n        this.button.classList.add(this.api.styles.inlineToolButton);\n        return this.button;\n    }\n    surround(range) {\n        if (!range) {\n            return;\n        }\n        const termWrapper = this.api.selection.findParentTag(this.tag, Monospace.CSS);\n    \n        // If start or end of selection is in the highlighted block\n        if (termWrapper) {\n            this.unwrap(termWrapper);\n        } else {\n            this.wrap(range);\n        }\n    }\n    // Wrap selection with term-tag\n    wrap(range) {\n        const m = document.createElement(this.tag);\n        m.classList.add(Monospace.CSS);\n        /** SurroundContent throws an error if the Range splits a non-Text node with only one of its boundary points\n         *  @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Range/surroundContents}\n         *  // range.surroundContents(span);\n         */\n        m.appendChild(range.extractContents());\n        range.insertNode(m);\n    \n        // Expand (add) selection to highlighted block\n        this.api.selection.expandToTag(m);\n    }\n    // Unwrap term-tag\n    unwrap(termWrapper) {\n        // Expand selection to all term-tag\n        this.api.selection.expandToTag(termWrapper);\n\n        const sel = window.getSelection();\n        const range = sel.getRangeAt(0);\n        const unwrappedContent = range.extractContents();\n    \n        // Remove empty term-tag\n        termWrapper.parentNode.removeChild(termWrapper);\n    \n        // Insert extracted content\n        range.insertNode(unwrappedContent);\n    \n        // Restore selection\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n    checkState() {\n        const termTag = this.api.selection.findParentTag(this.tag, Monospace.CSS);\n        this.button.classList.toggle(this.iconClasses.active, !!termTag);\n    }\n    static get sanitize() {\n        return {\n            code: {\n                class: Monospace.CSS,\n            },\n        };\n    }\n}\n\n/**\n * Initialize the EditorJS instance for the docs tab.\n * If data is provided, it will be used to populate the editor.\n * If data is not provided, or is false, the editor\n * will be initialized with an empty document.\n * @param {Object} data\n */\nexport function initialize_docs(data) {\n    let config = {\n        holder: 'docs-tab',\n        tools: {\n            underline: Underline,\n            monospace: Monospace,\n            header: {\n                class: Header,\n                inlineToolbar: true,\n            },\n            paragraph: {\n                class: Paragraph,\n                inlineToolbar: true,\n                config: {\n                    placeholder:\n                        'This panel can be used to document and describe your languge’s features in greater detail.',\n                },\n            },\n            table: {\n                class: Table,\n                inlineToolbar: true,\n                config: {\n                    rows: 3,\n                    cols: 3,\n                    withHeadings: true,\n                },\n            },\n        },\n    };\n    \n    if (data) config.data = data;\n    Docs.set(new EditorJS(config));\n};\n","<script lang='ts'>\n    import { initialize_docs } from '../scripts/docs.js';\n    initialize_docs(false);\n</script>\n<div class=\"tab-pane\" spellcheck=\"false\">\n    <div class=\"container row text-center\" style=\"height: 90vh; overflow-y: auto;\">\n        <div class=\"column\" style=\"font-family: Gentium\" id=\"docs-tab\"></div>\n    </div>\n</div>\n","const { ipcRenderer } = require('electron');\nconst fs = require('fs');\nconst path = require('path');\nimport { get } from 'svelte/store';\nimport { lexicon, alphabet, phrasebook, onsets, medials, codas, vowels, illegals, autosave,\n    romans_input, Docs, header_tags, case_sensitive, ignore_diacritics, file_name \n} from '../stores.js'\nimport { writeRomans } from './phonetics.js';\nimport { initialize_docs } from './docs.js';\n\n/**\n * This function is used to get the user's data path.\n * @param {function} callback\n */\nexport async function userData (callback) {\n    let path;\n    await ipcRenderer.invoke('getUserDataPath').then(result => {\n        path = result;\n    });\n    callback(path);\n}\n\n/**\n * This function is used to show the 'open' dialog at a specific \n * path, which can't be done with the default dialog API.\n * It calls back with the path to the file that the user selected.\n * @param {any} params\n * @param {function} callback\n */\nexport async function showOpenDialog (params, callback) {\n    let path;\n    await ipcRenderer.invoke('showOpenDialog', params).then(result => {\n        path = result;\n    });\n    callback(path);\n}\n\n/**\n * Collects all the data to be exported into one JSON string\n * or Blob object.\n * @param {boolean} return_blob\n * @returns {Blob | string} The data to be exported.\n */\nasync function collect_export_data (return_blob) {\n    let documentation;\n    await get(Docs).save().then(data => {\n        documentation = data;\n    });\n    const arrayify = (store) => get(store).trim().split(/\\s+/g);\n    // Version 2.0\n    let export_data = {\n        Version: 2.0,\n        Lexicon: get(lexicon),\n        Alphabet: get(alphabet).trim(),\n        Phrasebook: get(phrasebook),\n        Phonotactics: {\n            Onsets: arrayify(onsets),\n            Medials: arrayify(medials),\n            Codas: arrayify(codas),\n            Vowels: arrayify(vowels),\n            Illegals: arrayify(illegals),\n        },\n        Romanization: get(romans_input).trim(),\n        Docs: documentation,\n        HeaderTags: get(header_tags).trim(),\n        IgnoreDiacritics: get(ignore_diacritics),\n        CaseSensitive: get(case_sensitive),\n    };\n    let exports;\n    if (return_blob) {\n        exports = new Blob([JSON.stringify(export_data)]);\n    } else {\n        exports = JSON.stringify(export_data);\n    }\n    return exports;\n}\n\n/**\n * Converts the Editor.js JSON data to HTML and \n * appends it to the provided container element.\n * @param {Object} data The Editor.js JSON data\n * @param {HTMLElement} container The container element\n * @returns {HTMLElement} The container element with the HTML inserted\n */\nfunction editorjs_to_html(data, container) {\n    for (let element of data.blocks) {\n        switch (element.type) {\n            case 'header':\n                let header = document.createElement(\n                    `h${element.data.level}`\n                );\n                header.innerHTML = element.data.text;\n                container.appendChild(header);\n                break;\n            case 'paragraph':\n                let paragraph = document.createElement('p');\n                paragraph.innerHTML = element.data.text;\n                container.appendChild(paragraph);\n                break;\n            case 'table':\n                let table = document.createElement('table');\n                let tbody = document.createElement('tbody');\n                element.data.content.forEach(row => {\n                    let tr = document.createElement('tr');\n                    row.forEach(cell => {\n                        let td = document.createElement('td');\n                        td.innerHTML = cell;\n                        tr.appendChild(td);\n                    });\n                    tbody.appendChild(tr);\n                });\n                table.appendChild(tbody);\n                container.appendChild(table);\n                break;\n        }\n    }\n    return container;\n}\n\n/**\n * This function saves the language as a .lexc file\n * in the user's Lexicons folder.\n */\nexport async function save_file () {\n    if (!get(file_name).trim()) {\n        let name = window.prompt(\n            'Please enter a file name before saving.'\n        );\n        file_name.set(name);\n    }\n    let exports = await collect_export_data((blob = false)); // needs a string or buffer\n    try {\n        userData(user_path => {\n            if (!fs.existsSync(`${user_path}${path.sep}Lexicons${path.sep}`)) {\n                fs.mkdirSync(`${user_path}${path.sep}Lexicons${path.sep}`);\n            }\n            fs.writeFileSync(\n                `${user_path}${path.sep}Lexicons${path.sep}${get(file_name)}.lexc`,\n                exports,\n                'utf8'\n            );\n        });\n        if (!get(autosave)) {\n            window.alert('The file has been saved.');\n        } else {\n            new Notification(`The ${get(file_name)} file has been auto-saved.`);\n        }\n    } catch (err) {\n        window.alert(\n            'There was a problem saving your file. Please contact the developer.'\n        );\n        console.log(err);\n    }\n}\n\n/**\n * Contains the functions for exporting the language data\n * in various formats, asychronously.\n * @property {function} `lexc()` Exports the language as a .lexc file.\n * @property {function} `txt()` Saves the lexicon as a .txt file.\n * @property {function} `csv()` Saves the lexicon as a .csv file.\n * @property {function} `json()` Exports the raw JSON data.\n * @property {function} `html.all()` Exports the language as an interactive HTML file.\n * @property {function} `html.docs()` Exports the documentation alone as an HTML file.\n */ \nexport const saveAs = {\n    lexc: async () => {\n        let exports = await collect_export_data((true)); // needs a blob\n        let file_handle = await window.showSaveFilePicker({\n            suggestedName: `${get(f)}.lexc`,\n        });\n        await file_handle.requestPermission({ mode: 'readwrite' });\n        let file = await file_handle.createWritable();\n        try { await file.write(exports); } catch (err) {\n            window.alert('The file failed to save. Please contact the developer for assistance.');\n            console.log(err);\n            await file.close();\n            return;\n        }\n        await file.close();\n        window.alert('The file saved successfully.');\n    },\n    txt: async () => {\n        let export_data = '';\n        const $lexicon = get(lexicon);\n        for (let word in $lexicon) {\n            export_data += `${word}\\n${$lexicon[word][0]}\\n${$lexicon[word][1]}\\n\\n`;\n        }\n        let exports = new Blob([export_data]);\n    \n        let file_handle = await window.showSaveFilePicker({\n            suggestedName: `${get(file_name)}.txt`,\n        });\n        await file_handle.requestPermission({ mode: 'readwrite' });\n        let file = await file_handle.createWritable();\n        try {\n            await file.write(exports);\n        } catch (err) {\n            window.alert('The file failed to export.');\n        }\n        await file.close();\n        window.alert('The file exported successfully.');\n    },\n    csv: async () => {\n        const $lexicon = get(lexicon);\n        const array_to_csv = (data) => {\n            return data.map(row => row\n                    .map(String) // convert every value to String\n                    .map(v => v.replaceAll('\"', '\"\"')) // escape double colons\n                    .map(v => `\"${v}\"`) // quote it\n                    .join(',') // comma-separated\n                ).join('\\r\\n'); // rows starting on new lines\n        }\n        let arr_data = [['Word', 'Pronunciation', 'Definition']];\n        for (let key in $lexicon) {\n            arr_data.push([key, $lexicon[key][0], $lexicon[key][1]]);\n        }\n        let export_data = array_to_csv(arr_data);\n        let exports = new Blob([export_data]);\n    \n        let file_handle = await window.showSaveFilePicker({\n            suggestedName: `${get(file_name)}.csv`,\n        });\n        await file_handle.requestPermission({ mode: 'readwrite' });\n        let file = await file_handle.createWritable();\n        try {\n            await file.write(exports);\n        } catch (err) {\n            window.alert('The file failed to export. Please contact the developer for assistance.');\n            console.log(err);\n        };\n        await file.close();\n        window.alert('The file exported successfully.');\n    },\n    json: async () => {\n        let export_data = collect_export_data(true);\n\n        let file_handle = await window.showSaveFilePicker({\n            suggestedName: `${get(file_name)}.json`,\n        });\n        await file_handle.requestPermission({ mode: 'readwrite' });\n        let file = await file_handle.createWritable();\n        try {\n            await file.write(export_data);\n        } catch (err) {\n            window.alert('The file failed to export.');\n        }\n        await file.close();\n        window.alert('The file exported successfully.');\n    },\n    html: {\n        all: async () => {\n            // Create HTML document object\n            let export_container = document.createElement('html');\n    \n            // Create HTML header info\n            let head = document.createElement('head');\n            head.innerHTML = `\n                <meta charset=\"UTF-8\" />\n                <title>${get(file_name)}</title>\n                <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n                <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n                <link href=\"https://fonts.googleapis.com/css2?family=Gentium+Book+Plus:ital,wght@0,400;0,700;1,400;1,700&display=swap\" rel=\"stylesheet\">\n            `;\n            // Create export scripts\n            let scripts = document.createElement('script');\n            scripts.innerHTML = `\n                const lex_body = document.getElementById('lex-body');\n                const entry_count = document.getElementById('entry-counter');\n                const srch_wrd = document.getElementById('search-wrd');\n                const srch_def = document.getElementById('search-def');\n                const srch_tag = document.getElementById('search-tag');\n                const srch_phrase = document.getElementById('search-phrase');\n                const srch_descriptions = document.getElementById('search-description');\n                const cat_body = document.getElementById('category-body');\n                const book_body = document.getElementById('phrasebook-body');\n                const variant_body = document.getElementById('variants-body');\n                const lexicon = ${JSON.stringify(get(lexicon))};\n                const phrasebook = ${JSON.stringify(get(phrasebook))};\n                let selected_cat;\n    \n                function sort_lex_keys() {\n                    let htags = ${JSON.stringify(\n                        get(header_tags).toLowerCase().trim().split(/\\\\s+/)\n                    )};\n                    let all_words = structuredClone(lexicon)\n                    let tag_ordered_lexes = []\n                    for (let tag of htags) {\n                        tag_ordered_lexes.push([])\n                        for (let word in all_words) {\n                            if (lexicon[word][3].includes(tag)) {\n                                tag_ordered_lexes[tag_ordered_lexes.length-1].push(word)\n                            }\n                        }\n                        // console.log(tag_ordered_lexes, tag_ordered_lexes[tag_ordered_lexes.length-1])\n                        for (let w of tag_ordered_lexes[tag_ordered_lexes.length-1]) {\n                            delete all_words[w];\n                        }\n                    }\n                    let remaining_words = []\n                    for (let w in all_words) {remaining_words.push(w)}\n                    tag_ordered_lexes.push(remaining_words)\n                \n                    // Lowercase alphabet if case-sensitivity is unticked\n                    var alphabet = ${\n                        get(case_sensitive)\n                        ? JSON.stringify(alphabet_input.value.trim()) \n                        : JSON.stringify(alphabet_input.value.trim().toLowerCase())\n                    };\n                    let order = alphabet.trim().split(/\\\\s+/);\n                    // to make sure we find the largest tokens first, i.e. for cases where 'st' comes before 'str' alphabetically\n                    find_in_order = Array.from(new Set(order)).sort((a, b) => b.length - a.length); // descending, ensures uniqueness\n                \n                    let final_sort = [];\n                    for (let group of tag_ordered_lexes) {\n                        let lex = {};\n                        let list = [];\n                        for (let word of group) {\n                            // case sensitivity\n                            let w = ${ get(case_sensitive)? 'word' : 'word.toLowerCase()' };\n                \n                            // diacritic sensitivity\n                            w = ${ get(ignore_diacritics)? 'w.normalize(\"NFD\").replace(/\\\\p{Diacritic}/gu, \"\")' : 'w' };\n                \n                            for (let token of find_in_order) {\n                                w = w.replace(new RegExp(\\`\\${token}\\`, 'g'), \\`\\${order.indexOf(token)}.\\`)\n                            }\n                            append = w.split('.');\n                            for (let i of append) { append[append.indexOf(i)] = +i || 0 }\n                            lex[word] = append;\n                            list.push(append);\n                        }\n                        list.sort( (a, b) => {\n                            for (let i of a) {\n                                let j = b[a.indexOf(i)];\n                                if (i === j) { continue };\n                                return i - j;\n                            }\n                            return 0;\n                        });\n                        let sorted = [];\n                        for (let key in lex) { sorted.push([key, list.indexOf(lex[key])]) } // [ [word, index], [word, index], ...]\n                        sorted.sort((a, b) => a[1] - b[1]);\n                        for (let i = 0; i < sorted.length; i++) {\n                            sorted[i] = sorted[i][0];\n                        }\n                        for (let i of sorted) {\n                            final_sort.push(i)\n                        }\n                    }\n                    return final_sort;\n                }\n                function rewrite_entries(keys = false) {\n                    let sorted_keys = sort_lex_keys();\n                    lex_body.replaceChildren();\n                \n                    if (sorted_keys.length !== 0) {\n                        for (let key of sorted_keys) {\n                            if ( !keys || keys.includes(key) ) {\n                                let entry = document.createElement('div');\n                                entry.className = 'lex-entry';\n                                entry.id = key;\n                                \n                                let word = document.createElement('p');\n                                word.appendChild( document.createTextNode(key) );\n                                word.style.fontStyle = 'italic';\n                                \n                                let pron = document.createElement('p');\n                                pron.className = 'pronunciation';\n                                pron.appendChild( document.createTextNode(lexicon[key][0]) );\n                                \n                                let defn = document.createTextNode(lexicon[key][1]);\n                                \n                                let tags = document.createElement('div');\n                                for (let tag of lexicon[key][3]) {\n                                    let newTag = document.createElement('div');\n                                    newTag.appendChild( document.createTextNode(tag) );\n                                    newTag.className = 'tag-item';\n                                    tags.appendChild(newTag);\n                                }\n                                \n                                entry.append(word, pron, tags, defn);\n                \n                                lex_body.appendChild(entry);\n                            }\n                        }\n                    }\n                    if (!keys) {\n                        var count = document.createTextNode(\\`\\${Object.keys(lexicon).length} Entries\\`);\n                    } else {\n                        var count = document.createTextNode(\\`\\${keys.length} Matches\\`);\n                    }\n                    entry_count.replaceChildren(count)\n                }\n                function search_lex() {\n                    let s = srch_wrd.value.trim();\n                    let z = srch_def.value.toLowerCase().trim();\n                    let x = srch_tag.value.trim();\n                    if (s === 'Search by word…'){s = ''};\n                    if (z === 'search definition…'){z = ''};\n                    if (x === 'Search by tags…' || x === ''){ x = [] } else { x = x.split(/\\\\s+/g) }\n                    let keys = false;\n                    if (s !== '' || z !== '' || x.length !== 0 ) {\n                        let l = [s + '|', z + '|'];\n                        // Turn l into a list of [search by word terms, search by def terms]\n                        for (let e of l) {\n                            let n = l.indexOf(e);\n                            l[n] = [];\n                            e = e.split('|');\n                            for (let a of e) { l[n].push( a.trim() ); }\n                        }\n                        keys = [];\n                        for (let word in lexicon) {\n                            let w = \\`^\\${word}^\\`;\n                            let match = true;\n                            for (let a of l[0]) { // words\n                                if ( !w.includes(a) ) { match = false; }\n                            }\n                            for (let a of l[1]) { // definitions\n                                if ( !lexicon[word][1].toLowerCase().includes(a) ) { match = false; }\n                            }\n                            if (lexicon[word][3].length !== 0) {\n                                let any_tag_match;\n                                for (let tag of lexicon[word][3]) {\n                                    for (let a of x) { // tags\n                                        if (\\`^\\${tag}^\\`.includes(a)) { any_tag_match = true; }\n                                    }\n                                }\n                                if (!any_tag_match) { match = false; }\n                            } else {\n                                if (x.length !== 0) { match = false; }\n                            }\n                            if (match) { keys.push(word); }\n                        }\n                    }\n                    rewrite_entries(keys);\n                }\n                srch_wrd.onkeyup = search_lex; \n                srch_def.onkeyup = search_lex;\n                srch_tag.onkeyup = search_lex;\n                srch_wrd.onfocus = function() {\n                    if (srch_wrd.value === 'Search by word…') {\n                        srch_wrd.style.color = 'white';\n                        srch_wrd.value = '';\n                    }\n                }\n                srch_wrd.onblur = function() {\n                    if (srch_wrd.value === '') {\n                        srch_wrd.value = 'Search by word…';\n                    }\n                }\n                srch_def.onfocus = function() {\n                    if (srch_def.value === 'Search definition…') {\n                        srch_def.style.color = 'white';\n                        srch_def.value = '';\n                    }\n                }\n                srch_def.onblur = function() {\n                    if (srch_def.value === '') {\n                        srch_def.value = 'Search definition…';\n                    }\n                }\n                srch_tag.onfocus = function() {\n                    if (srch_tag.value === 'Search by tags…') {\n                        srch_tag.style.color = 'white';\n                        srch_tag.value = '';\n                    }\n                }\n                srch_tag.onblur = function() {\n                    if (srch_tag.value === '') {\n                        srch_tag.value = 'Search by tags…';\n                    }\n                }\n                srch_wrd.onblur(); srch_def.onblur(); srch_tag.onblur();\n                \n                function update_book(keys=false) {\n                    if (!keys) { keys = [false] }\n                    if (selected_cat) { // make sure category isn't blank\n                        while (book_body.firstChild) {\n                            book_body.removeChild(book_body.lastChild)\n                        }\n                        let title = document.createElement(\"p\");\n                        title.classList = 'table-title capitalize';\n                        title.appendChild( document.createTextNode( selected_cat.toLowerCase()) );\n                        book_body.append(title, /* document.createElement('hr') */ );\n                \n                        for (let entry in phrasebook[selected_cat]) {\n                            if (keys.indexOf(entry) !== -1 || keys[0] === false) {\n                                // base entry\n                                let entry_container = document.createElement('div');\n                                entry_container.className = 'lex-entry';\n                                let phrase = document.createElement('p');\n                                phrase.appendChild( document.createTextNode(entry) );\n                                phrase.style.fontStyle = 'italic';\n                                let pron = document.createElement('p');\n                                pron.className = 'pronunciation';\n                                pron.appendChild( document.createTextNode(phrasebook[selected_cat][entry].pronunciation) );\n                                let desc = document.createElement('p');\n                                desc.className = 'prelined';\n                                desc.appendChild( document.createTextNode(phrasebook[selected_cat][entry].description) );\n                                entry_container.append(phrase, pron, desc);\n                                // variant entries\n                \n                                if ( Object.keys(phrasebook[selected_cat][entry].variants).length > 0) {\n                                    let t = document.createElement('p');\n                                    t.appendChild( document.createTextNode('⋲ ᴠᴀʀɪᴀɴᴛꜱ ⋺') );\n                                    entry_container.append(t);\n                \n                                    var it = 0;\n                                    var crow = document.createElement('div');\n                                    crow.classList = 'row variants';\n                                    entry_container.appendChild(crow);\n                                    for (variant in phrasebook[selected_cat][entry].variants) {\n                                        it++;\n                                        if (it === 4) {\n                                            it = 0;\n                                            entry_container.appendChild(crow);\n                                            var crow = document.createElement('div');\n                                            crow.classList = 'row variants';\n                                            entry_container.appendChild(crow);\n                                        }\n                                        let vcol = document.createElement('div');\n                                        vcol.className = 'column';\n                \n                                        let v_phrase = document.createElement('p');\n                                        v_phrase.appendChild( document.createTextNode(variant) );\n                                        v_phrase.style.fontStyle = 'italic';\n                                        let v_pron = document.createElement('p');\n                                        v_pron.className = 'pronunciation';\n                                        v_pron.appendChild( document.createTextNode(phrasebook[selected_cat][entry].variants[variant].pronunciation) );\n                                        let v_desc = document.createElement('p');\n                                        v_desc.className = 'prelined';\n                                        v_desc.appendChild( document.createTextNode(phrasebook[selected_cat][entry].variants[variant].description) );\n                        \n                                        vcol.append(v_phrase, v_pron, v_desc);\n                                        crow.appendChild(vcol);                    \n                                    }\n                                }\n                \n                                entry_container.addEventListener('click', () => edit_book_entry(entry)); // edit functionality\n                                book_body.appendChild(entry_container);\n                            }\n                        }\n                    } else { book_body.replaceChildren(); }\n                }\n                \n                function update_categories() {\n                    while (cat_body.firstChild) {\n                        cat_body.removeChild(cat_body.lastChild);\n                    }\n                    for (let cat in phrasebook) {\n                        let i = document.createElement(\"div\");\n                        i.appendChild( document.createTextNode(cat) );\n                        i.className = 'lex-entry capitalize';\n                        i.onclick = function () { \n                            selected_cat = cat; \n                            update_book();\n                        };\n                        cat_body.appendChild(i);\n                    };\n                    update_book();\n                }\n                \n                srch_phrase.onfocus = function() {\n                    if (srch_phrase.value === 'Search by phrase…') {\n                        srch_phrase.style.color = 'white';\n                        srch_phrase.value = '';\n                    }\n                }\n                srch_phrase.onblur = function() {\n                    if (srch_phrase.value === '') {\n                        srch_phrase.value = 'Search by phrase…';\n                    }\n                }\n                srch_descriptions.onfocus = function() {\n                    if (srch_descriptions.value === 'Search descriptions…') {\n                        srch_descriptions.style.color = 'white';\n                        srch_descriptions.value = '';\n                    }\n                }\n                srch_descriptions.onblur = function() {\n                    if (srch_descriptions.value === '') {\n                        srch_descriptions.value = 'Search descriptions…';\n                    }\n                }\n                srch_phrase.onblur(); srch_descriptions.onblur();\n                \n                function search_book() {\n                    let scope = phrasebook[selected_cat];\n                    let ps = srch_phrase.value.trim();\n                    let ds = srch_descriptions.value.toLowerCase().trim();\n                    if (ps === 'Search by phrase…') {ps = ''};\n                    if (ds === 'search descriptions…') {ds = ''};\n                    let keys = false;\n                    if (ps !== '' || ds !== '') {\n                        keys = [];\n                        for (let entry in scope) {\n                            let term = '^' + entry + '^';\n                            let pm = !ps.length;\n                            let dm = !ds.length;\n                            // console.log(scope[entry].description, scope[entry].description.includes(ds));\n                            if (term.includes(ps)) {\n                                pm = true;\n                            }\n                            if ( scope[entry].description.toLowerCase().includes(ds) ) {\n                                dm = true;\n                            } \n                            for (let variant in scope[entry].variants) {\n                                let v_term = '^' + variant + '^';\n                                if (v_term.includes(ps)) {\n                                    pm = true;\n                                }\n                                if (scope[entry].variants[variant].description.toLowerCase().includes(ds)) {\n                                    dm = true;\n                                }\n                            }\n                            console.log(pm, dm, ps, ds, entry);\n                            if (pm && dm) {\n                                keys.push(entry);\n                            }\n                        }\n                    }\n                    update_book(keys);\n                }\n                srch_phrase.onkeyup = search_book;\n                srch_descriptions.onkeyup = search_book;\n    \n                update_book();\n                update_categories();\n                rewrite_entries();\n            `;\n            // Create export styles\n            let styles = document.createElement('style');\n            styles.innerHTML = fs.readFileSync(\n                path.join(path.dirname(__dirname), 'styles/index.css'),\n                'utf8'\n            );\n            let theme = document.createElement('style');\n            theme.innerHTML = fs.readFileSync(\n                path.join(path.dirname(__dirname), theme_select.value),\n                'utf8'\n            );\n            let overrides = document.createElement('style');\n            overrides.innerHTML = fs.readFileSync(\n                path.join(path.dirname(__dirname), 'styles/html_export.css'),\n                'utf8'\n            );\n    \n            let documentation = document.createElement('div');\n            documentation.classList.add('container', 'column', 'scrolled');\n            // Convert EditorJS save data to HTML.\n            await get(Docs).save().then(data => {\n                documentation = editorjs_to_html(data, documentation);\n            });\n    \n            // Create export body\n            let body = document.createElement('body');\n            body.innerHTML = `\n                <h1>${get(file_name)}</h1>\n                <div class='tab-pane text-center'>\n                    <div class=\"row\" style=\"max-height: 90vh\">\n                        <div class='container column'>\n                            <div class='search-row'>\n                                <div class=\"column\">\n                                    <label for=\"search-wrd\" style=\"display: none\">Search by word</label>\n                                    <input id=\"search-wrd\" type=\"text\" class=\"search\" />\n                                </div>\n                                <div class=\"column\">\n                                    <label for=\"search-tag\" style=\"display: none\">Search by tags</label>\n                                    <input id=\"search-tag\" type=\"text\" class=\"search\" />\n                                </div>\n                            </div>\n                            <label for=\"search-def\" style=\"display: none\">Search definitions</label>\n                            <input id=\"search-def\" type=\"text\" class=\"search\">\n                            <div class='scrolled' style=\"height: 64vh\">\n                                <p class=\"prelined lex-body\" id=\"lex-body\">The lexicon should appear here.</p>\n                            </div>\n                            <p id=\"entry-counter\"></p>\n                        </div>\n                        ${documentation.outerHTML}\n                    </div>\n    \n                    <!-- Phrasebook -->\n                    <div class=\"row\" style=\"height:90vh;\">\n                        <!-- Categories -->\n                        <div class=\"container column sidebar\">\n                            <p>Categories</p>\n                            <hr />\n                            <div class=\"column scrolled\" style=\"max-height: 90%;\" id=\"category-body\">\n                                <p class=\"info\">Phrasebook categories appear here.</p>\n                            </div>\n                        </div>\n                        <div class=\"container column\">\n                            <!-- Search Fields -->\n                            <div class=\"search-row\">\n                                <div class=\"column\">\n                                    <label for=\"search-phrase\" style=\"display: none\">Search by phrase…</label>\n                                    <input id=\"search-phrase\" type=\"text\" class=\"search\" />\n                                </div>\n                                <div class=\"column\">\n                                    <label for=\"search-description\" style=\"display: none\">Search descriptions…</label>\n                                    <input id=\"search-description\" type=\"text\" class=\"search\" />\n                                </div>\n                            </div>\n                            <!-- Book -->\n                            <div class=\"column scrolled\" id=\"phrasebook-body\" style=\"max-height: 80%;\">\n                                <p class=\"info\">Select a category from the left.</p>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n                <br><br>\n            `;\n    \n            head.append(styles, theme, overrides);\n            export_container.append(head, body, scripts);\n    \n            let export_data = export_container.outerHTML;\n            let exports = new Blob(['\\ufeff', export_data], {\n                type: 'tex/html; charset=utf-8;',\n            });\n    \n            let file_handle = await window.showSaveFilePicker({\n                suggestedName: `${get(file_name)}.html`,\n            });\n            await file_handle.requestPermission({ mode: 'readwrite' });\n            let file = await file_handle.createWritable();\n            try {\n                console.log(typeof exports);\n                await file.write(exports);\n            } catch (err) {\n                window.alert('The file failed to export. Please contact the developer for assistance.');\n                console.log(err);\n                await file.close();\n                return;\n            }\n            await file.close();\n            window.alert('The file exported successfully.');\n        },\n        docs: async () => {\n            // Create HTML document object\n            let export_container = document.createElement('html');\n    \n            // Create HTML header info\n            let head = document.createElement('head');\n            head.innerHTML = `\n                <meta charset=\"UTF-8\" />\n                <title>${get(file_name)} Docs</title>\n                <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n                <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n                <link href=\"https://fonts.googleapis.com/css2?family=Gentium+Book+Plus:ital,wght@0,400;0,700;1,400;1,700&display=swap\" rel=\"stylesheet\">\n            `;\n            // Create export styles\n            let styles = document.createElement('style');\n            styles.innerHTML = fs.readFileSync(\n                path.join(path.dirname(__dirname), 'styles/index.css'),\n                'utf8'\n            );\n            let theme = document.createElement('style');\n            theme.innerHTML = fs.readFileSync(\n                path.join(path.dirname(__dirname), theme_select.value),\n                'utf8'\n            );\n            let overrides = document.createElement('style');\n            overrides.innerHTML = fs.readFileSync(\n                path.join(path.dirname(__dirname), 'styles/html_export.css'),\n                'utf8'\n            );\n            head.append(styles, theme, overrides);\n            export_container.appendChild(head);\n    \n            let body = document.createElement('body');\n            await get(Docs).save().then(data => {\n                body = editorjs_to_html(data, body);\n            });\n            body.style.padding = \"12em\";\n            body.classList.add('container');\n            export_container.appendChild(body);\n    \n            let export_data = export_container.outerHTML;\n            let exports = new Blob(['\\ufeff', export_data], {\n                type: 'tex/html; charset=utf-8;',\n            });\n            let file_handle = await window.showSaveFilePicker({\n                suggestedName: `${get(file_name)}_Docs.html`,\n            });\n            await file_handle.requestPermission({ mode: 'readwrite' });\n            let file = await file_handle.createWritable();\n            try {\n                await file.write(exports);\n            } catch (err) {\n                window.alert('The file failed to export. Please contact the developer.');\n                console.log(err);\n                await file.close();\n                return;\n            }\n            await file.close();\n            window.alert('The file exported successfully.');\n        },\n    },\n};\n\n/**\n * Methods for opening files saved by previous versions of the app.\n * @param {Object} contents\n */\nexport const openLegacy = {\n    /**\n     * This function can open 1.9 - 1.11 files.\n     */\n    1.9: (contents) => {\n        try { lexicon.set(contents.Lexicon); } catch (err) {\n            window.alert('There was a problem loading the contents of the lexicon. Please contact the developer.');\n            console.log(err);\n        }\n        try { alphabet.set(contents.Alphabet); } catch (err) {\n            window.alert('There was a problem loading the alphabetical order. Please contact the developer for assistance.');\n            console.log(err);\n        }\n        try {\n            romans_input.set(contents.Romanization);\n            writeRomans();\n        } catch (err) {\n            window.alert('There was a problem loading the romanizations. Please contact the developer for assistance.');\n            console.log(err);\n        }\n        try { phrasebook.set(contents.Phrasebook); } catch (err) {\n            window.alert('There was a problem loading the phrasebook. Please contact the developer for assistance.');\n            console.log(err);\n        }\n        try {\n            onsets.set(contents.Phonotactics.Initial.join(' '));\n            medials.set(contents.Phonotactics.Middle.join(' '));\n            codas.set(contents.Phonotactics.Final.join(' '));\n            vowels.set(contents.Phonotactics.Vowel.join(' '));\n            illegals.set(contents.Phonotactics.Illegal.join(' '));\n        } catch (err) {\n            window.alert('There was a problem loading the phonotactics data. Please contact the developer for assistance.');\n            console.log(err);\n        }\n        try { \n            get(Docs).destroy();\n            initialize_docs(contents.Docs); \n        } catch (err) {\n            window.alert('There was a problem loading the documentation data. Please contact the developer for assistance.');\n            console.log(err);\n        }\n        try { header_tags.set(contents.HeaderTags); } catch (err) {\n            window.alert('There was a problem loading the header tags.');\n            console.log(err);\n        }\n        ignore_diacritics.set(contents.IgnoreDiacritics);\n        case_sensitive.set(contents.CaseSensitive);\n    },\n}\n\n/**\n * Imports a CSV file to the lexicon.\n * @param {boolean} headers Whether or not the CSV file has headers.\n * @param {any} words The column number of the words.\n * @param {any} definitions The column number of the definitions.\n */\nexport async function import_csv(headers, words, definitions) {\n    let [file_handle] = await window.showOpenFilePicker();\n    await file_handle.requestPermission({ mode: 'read' });\n    let file = await file_handle.getFile();\n    if (!file.name.includes('.csv')) {\n        window.alert('The selected file was not a .csv file.');\n        return;\n    }\n    let r = headers;\n    let w = words - 1;\n    let d = definitions - 1;\n\n    let data = await file.text();\n    let rows = data.split('\\r');\n    let $lexicon = {};\n    for (let row of rows) {\n        if (r === 'on' && row === rows[0]) continue;\n\n        let columns = row.split(',');\n        if (columns[0].includes('\\n\"')) {\n            columns[0] = columns[0].split('\\n\"')[1];\n        }\n        columns[columns.length - 1] = columns[columns.length - 1].replace(/\"$/g, '');\n\n        $lexicon[columns[w]] = [\n            get_pronunciation(columns[w]),\n            columns[d],\n            false,\n            [],\n        ];\n    }\n    lexicon.set($lexicon);\n    file_name.set(file.name.split('.')[0]);\n}\n","<script lang=\"ts\">\n    const fs = require('fs');\n    const path = require('path');\n    import { file_name, lexicon, phrasebook, alphabet, romans_input, \n        Docs, case_sensitive, ignore_diacritics, selected_category,\n        onsets, medials, codas, vowels, illegals, header_tags\n    } from '../stores.js';\n    import { userData, showOpenDialog, save_file, openLegacy, saveAs, import_csv } from '../scripts/files.js';\n    import { writeRomans } from '../scripts/phonetics.js';\n    import { initialize_docs } from '../scripts/docs.js';\n    $: loading_message = '';\n    let csv_headers = true; let csv_words = 2; let csv_definitions = 3;\n    let old_pattern = ''; let new_pattern = '';\n\n    /**\n     * Parses the contents of an opened .lexc file and loads the data into the app.\n     * If the file is a legacy version, it is passed to the appropriate function.\n     * @param {Object} contents - The contents of the opened file.\n     */\n    function read_contents (contents) {\n        if (contents.Version < 2) {\n            try { openLegacy[contents.Version](contents); }\n            catch (err) {\n                window.alert(`\n                    The file you attempted to open was saved by an old version of Lexicanter (Version ~${contents.Version}), \n                    which is no longer supported. Please contact the developer for assistance; the file is likely recoverable.\n                `);\n            }\n            return;\n        }\n        try {\n            loading_message = 'Loading settings...';\n            $case_sensitive = contents.CaseSensitive;\n            $ignore_diacritics = contents.IgnoreDiacritics;\n            $header_tags = contents.HeaderTags;\n            loading_message = 'Loading alphabet...';\n            $alphabet = contents.Alphabet;\n            loading_message = 'Loading lexicon...';\n            $lexicon = contents.Lexicon;\n            loading_message = 'Loading phrasebook...';\n            $phrasebook = contents.Phrasebook;\n            loading_message = 'Loading documentation...';\n            let docs_data = contents.Docs;\n            $Docs.destroy();\n            initialize_docs(docs_data);\n            $selected_category = Object.keys($phrasebook)[0]; \n            loading_message = 'Loading romanizations...';\n            $romans_input = contents.Romanization; writeRomans();\n            loading_message = 'Loading phonotactics...';\n            $onsets = contents.Phonotactics.Onsets.join(' ');\n            $medials = contents.Phonotactics.Medials.join(' ');\n            $codas = contents.Phonotactics.Codas.join(' ');\n            $vowels = contents.Phonotactics.Vowels.join(' ');\n            $illegals = contents.Phonotactics.Illegals.join(' ');\n        } catch (err) {\n            window.alert(\n                'There was a problem loading the contents of the file. Please contact the developer for assistance.'\n            );\n            console.log(err);\n        }\n    }\n    \n    /**\n     * Opens a .lexc file from the user app data folder.\n     */\n    async function open_file () {\n        let contents;\n        let dialog = user_path => {\n            showOpenDialog(\n                {\n                    title: 'Open Lexicon',\n                    defaultPath: `${user_path}${path.sep}Lexicons${path.sep}`,\n                    properties: ['openFile'],\n                },\n                file_path => {\n                    if (file_path === undefined) {\n                        // stop orbit animation\n                        document.querySelectorAll('.planet').forEach((planet: HTMLElement) => {\n                            planet.style.animationPlayState = 'paused';\n                        });\n                        loading_message = 'No file selected.';\n                        window.setTimeout(() => {\n                            loading_message = '';\n                        }, 5000);\n                        return;\n                    }\n                    fs.readFile(file_path[0], 'utf8', (err, data) => {\n                        if (err) {\n                            console.log(err);\n                            window.alert(\n                                'There was an issue loading your file. Please contact the developer.'\n                            );\n                            document.querySelectorAll('.planet').forEach((planet: HTMLElement) => {\n                                // loading anim stop\n                                planet.style.animationPlayState = 'paused';\n                            });\n                            loading_message = 'Couldn’t open file.';\n                            window.setTimeout(() => { loading_message = ''; }, 5000);\n                            return;\n                        }\n                        contents = JSON.parse(data);\n                        read_contents(contents);\n                        $file_name = path.basename(file_path[0], '.lexc');\n                        document.querySelectorAll('.planet').forEach((planet: HTMLElement) => {\n                            // loading anim stop\n                            planet.style.animationPlayState = 'paused';\n                        });\n                        loading_message = 'Done!';\n                        window.setTimeout(() => { loading_message = ''; }, 5000);\n                    });\n                }\n            );\n        };\n        document.querySelectorAll('.planet').forEach((planet: HTMLElement) => {\n            // loading anim start\n            planet.style.animationPlayState = 'running';\n        });\n        loading_message = 'Loading...';\n        await userData(user_path => {\n            if (!fs.existsSync(`${user_path}${path.sep}Lexicons${path.sep}`)) {\n                fs.mkdir(`${user_path}${path.sep}Lexicons${path.sep}`, () => {\n                    dialog(user_path);\n                });\n            } else { dialog(user_path); }\n        });\n    }\n    \n    /**\n     * Allows the user to import a .lexc file from their computer.\n     */\n    async function import_file() {\n        document.querySelectorAll('.planet').forEach((planet: HTMLElement) => {\n            planet.style.animationPlayState = 'running';\n        });\n        loading_message = 'Loading...';\n\n        let [file_handle] = await window.showOpenFilePicker();\n        await file_handle.requestPermission({ mode: 'read' });\n        let file = await file_handle.getFile();\n        if (!file.name.includes('.lexc')) {\n            window.alert('The selected file was not a .lexc file.');\n            document.querySelectorAll('.planet').forEach((planet: HTMLElement) => {\n                planet.style.animationPlayState = 'paused';\n            });\n            loading_message = 'Incorrect file type.';\n            window.setTimeout(() => { loading_message = ''; }, 5000);\n            return;\n        }\n        let string_contents = await file.text();\n        let contents = JSON.parse(string_contents);\n        read_contents(contents);\n        $file_name = file.name.split('.')[0];\n\n        document.querySelectorAll('.planet').forEach((planet: HTMLElement) => {\n            planet.style.animationPlayState = 'paused';\n        });\n        loading_message = 'Done!';\n        window.setTimeout(() => { loading_message = ''; }, 5000);\n    }\n\n    /**\n     * This function is used to change the a given orthograph\n     * to a new one, throughout the lexicon. \n     */\n    function change_orthography() {\n        old_pattern = old_pattern.replace(/\\^/g, '÷');\n        new_pattern = new_pattern.replace(/\\^/g, '÷');\n        for (let word in $lexicon) {\n            let w = '÷' + word + '÷';\n            if (w.includes($case_sensitive? old_pattern : old_pattern.toLowerCase())) {\n                let r = new RegExp(old_pattern, $case_sensitive ? 'g' : 'gi');\n                w = w.replace(r, new_pattern);\n                w = w.replace(/÷/gi, '');\n                if (w in $lexicon) {\n                    // if the new word exists, conjoin the definitions\n                    $lexicon[w][1] = $lexicon[w][1] + '\\n' + $lexicon[word][1];\n                } else {\n                    $lexicon[w] = $lexicon[word];\n                }\n                delete $lexicon[word];\n            }\n        }\n        writeRomans(); $lexicon = $lexicon;\n        old_pattern = ''; new_pattern = '';\n    }\n\n</script>\n<!-- File Tab -->\n<div class=\"tab-pane\">\n    <div class=\"row\" style=\"height: 95vh\">\n        <div class=\"column container\" style=\"overflow-y:auto\">\n            <p>Document</p>\n            <label for=\"file-name\">Name</label>\n            <input type=\"text\" id=\"file-name\" bind:value={$file_name}/>\n            <br>\n            <div class=\"narrow row\">\n                <div class=\"column\">\n                    <button on:click={save_file} class=\"hover-highlight hover-shadow\">Save…</button>\n                    <button on:click={open_file} class=\"hover-highlight hover-shadow\">Open…</button>\n                    <p class=\"info\">Save your lexicon or open a previously saved one.</p>\n                </div>\n                <div class=\"column\"> \n                    <div class=\"milkyWay\">\n                        <!-- Loader -->\n                        <div class=\"sun\"></div>\n                        {#each ['mercury', 'venus', 'earth', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune', 'pluto'] as planet}\n                             <div class=\"planet {planet}\"></div>\n                        {/each}\n                    </div>\n                    <p>{loading_message}</p>\n                </div>\n                <div class=\"column\">\n                    <button on:click={saveAs.lexc} class=\"hover-highlight hover-shadow\">Export…</button>\n                    <button on:click={import_file} class=\"hover-highlight hover-shadow\">Import…</button>\n                    <p class=\"info\">Export and import your own copies of the lexicon file.</p>\n                </div>\n            </div>\n            <br>\n            <p>Lexicon Header Tags</p>\n            <div class=\"narrow\">\n                <textarea bind:value={$header_tags}></textarea>\n                <label for=\"header-tags\" class=\"info\">\n                    Entries with these tags will be sorted separately at the top of the lexicon.\n                </label>\n            </div>\n            <br>\n            <button class=\"hover-highlight hover-shadow\"\n                on:click={() => window.open('index.html', '_blank', 'height=900, width=900')}>Open New Window</button>\n            <br>\n            <p>Change Pronunciations & Orthography</p>\n            <div class=\"narrow\">\n                <label for=\"ortho-pattern\">Orthography Pattern</label>\n                <input id=\"ortho-pattern\" type=\"text\" bind:value={old_pattern}/>\n                <label for=\"new-pattern\">Replace With</label>\n                <input id=\"new-pattern\" type=\"text\" bind:value={new_pattern}/>\n                <button class=\"hover-highlight hover-shadow\" on:click={change_orthography}>Commit Change</button>\n            </div>\n            <br>\n            <p>Export Lexicon</p>\n            <p>HTML</p>\n            <div class=\"row narrow\">\n                <div class=\"column\">\n                    <button on:click={saveAs.html.all} class=\"hover-highlight hover-shadow\">Everything</button>\n                </div>\n                <div class=\"column\">\n                    <button on:click={saveAs.html.docs} class=\"hover-highlight hover-shadow\">Docs Only</button>\n                </div>\n            </div>\n            <button on:click={saveAs.txt} class=\"hover-highlight hover-shadow\">Text File</button>\n            <button on:click={saveAs.csv} class=\"hover-highlight hover-shadow\">CSV</button>\n            <button on:click={saveAs.json} class=\"hover-highlight hover-shadow\">JSON</button>\n            <br>\n            <p>Import Lexicon from CSV</p>\n            <div class=\"narrow\">\n                <div class=\"row\">\n                    <div class=\"column\">\n                        <label for=\"word-column\">Words Column</label>\n                        <input type=\"number\" id=\"word-column\" bind:value={csv_words}/>\n                    </div>\n                    <div class=\"column\">\n                        <label for=\"def-column\">Definitions Column</label>\n                        <input type=\"number\" id=\"def-column\" bind:value={csv_definitions}/>\n                    </div>\n                </div>\n            </div>\n            <label for=\"row-one-is-labels\">First Row Is Column Labels</label>\n            <input type=\"checkbox\" id=\"row-one-is-labels\" bind:checked={csv_headers}/>\n            <button on:click={() => import_csv(csv_headers, csv_words, csv_definitions)} class=\"hover-highlight hover-shadow\">Import</button>\n            <br><br>\n        </div>\n    </div>\n</div>\n","<script lang=\"ts\">\n    import { theme, autosave } from '../stores.js';\n    import { userData, save_file } from '../scripts/files.js'\n    const fs = require('fs');\n    const path = require('path');\n\n    /**\n     * When the app loads, this block runs to check if the user has\n     * previously set a theme preference. If not, it creates a file in the\n     * user's app data folder and sets the default value to 'styles/dark.css'. \n     * Otherwise, it reads the value from the file and sets the $theme store.\n     */\n    userData(user_path => {\n        if (!fs.existsSync(user_path + path.sep + 'theme.txt')) {\n            fs.writeFileSync(user_path + path.sep + 'theme.txt', 'styles/dark.css');\n        }\n        let theme_value = fs\n            .readFileSync(user_path + path.sep + 'theme.txt', 'utf8')\n            .toString();\n\n        $theme = theme_value;\n    });\n\n    /**\n     * When the app loads, this block runs to check if the user has\n     * previously set an autosave preference. If not, it creates a file in the\n     * user's app data folder and sets the default value to true. Otherwise,\n     * it reads the value from the file and sets the $autosave store.\n     */\n    userData(user_path => {\n        if (!fs.existsSync(user_path + path.sep + 'autosave_pref.txt')) {\n            fs.writeFileSync(user_path + path.sep + 'autosave_pref.txt', 'false');\n            $autosave = true;\n        } else {\n            $autosave = fs.readFileSync(user_path + path.sep + 'autosave_pref.txt', 'utf8') === 'true';\n        }\n    });\n\n    /**\n     * When the user changes selected theme from the dropdown in the Settings tab,\n     * this function updates the preferred theme setting stored in user app data.\n     */\n    function change_theme() {\n        userData(user_path => {\n            fs.writeFile(user_path + path.sep + 'theme.txt', $theme, err => {\n                if (err) { \n                    window.alert('There was a problem loading your theme. Please contact the developer for assistance.'); \n                    console.log(err) \n                };\n            });\n        });\n    }\n\n    /**\n     * When the user clicks the \"Choose Custom Theme\" button in the Settings tab,\n     * this function opens a file picker dialog and allows the user to select\n     * a .css file. The file is then copied to the user's app data folder and \n     * the theme is updated to use the new file.\n     */ \n    async function custom_theme() {\n        let [file_handle] = await window.showOpenFilePicker();\n        await file_handle.requestPermission({ mode: 'read' });\n        let file = await file_handle.getFile();\n        if (!file.name.includes('.css')) {\n            window.alert('The selected file was not a .css file.');\n            return;\n        }\n        let contents = await file.text();\n        let theme_path;\n        await userData(user_path => {\n            let themes_dir = user_path + path.sep + 'user_themes' + path.sep;\n            if (!fs.existsSync(themes_dir)) {\n                fs.mkdirSync(themes_dir);\n            }\n            theme_path = user_path + path.sep + 'user_themes' + path.sep + file.name;\n            fs.writeFile(theme_path, contents, 'utf8', err => {\n                if (err) throw err;\n                $theme = theme_path;\n            });\n            fs.writeFile(user_path + path.sep + 'theme.txt', theme_path, err => {\n                if (err) throw err;\n            });\n        });\n    }\n\n    /**\n     * When the user changes the autosave setting in the Settings tab, this function\n     * updates the preferred autosave setting stored in user app data.\n     */ \n    function change_autosave_pref () {\n        userData(user_path => {\n            fs.writeFile(\n                user_path + path.sep + 'autosave_pref.txt',\n                String($autosave),\n                'utf8',\n                err => { if (err) throw err; }\n            );\n        });\n        if ($autosave) {\n            var autosave_tracker = window.setInterval(\n                save_file,\n                300000 /* 5 minutes */,\n                false\n            );\n        } else {\n            window.clearInterval(autosave_tracker);\n        };\n    };\n\n</script>\n<!-- App Settings -->\n<div class=\"tab-pane\">\n    <div class=\"row\" style=\"height: 95vh\">\n        <div class=\"container column scrolled\" style=\"height: 90vh;\">\n            <p>Appearance Settings</p> <br>\n            <label for=\"theme-select\">Color Theme</label>\n            <select name=\"theme-select\" id=\"theme-select\" bind:value={$theme} on:change={change_theme}>\n                <optgroup label=\"Simple Themes\">\n                    <option value=\"styles/dark.css\">☾ Dark</option>\n                    <option value=\"styles/light.css\">☀ Light</option>\n                </optgroup>\n                <optgroup label=\"The Saturnine Collection\">\n                    <option value=\"styles/marine.css\">☾ Marine</option>\n                    <option value=\"styles/glade.css\">☾ Glade</option>\n                    <option value=\"styles/pomegranate.css\">☾ Pomegranate</option>\n                    <option value=\"styles/leatherbound.css\">☀ Leatherbound</option>\n                    <option value=\"styles/wisteria.css\">☀ Wisteria</option>\n                </optgroup>\n                <optgroup label=\"The Maarz Collection\">\n                    <option value=\"styles/purple_maar.css\">☾ Purple Maar</option>\n                    <option value=\"styles/terminal_green.css\">☾ Terminal</option>\n                </optgroup>\n            </select>\n            <br><br>\n            <button on:click={custom_theme} class=\"hover-highlight hover-shadow\">Load Custom Theme…</button>\n            <br><br>\n            <p>Saving Settings</p>\n            <label for=\"auto-save\">Auto-Save</label>\n            <input type=\"checkbox\" id=\"auto-save\" bind:checked={$autosave} on:change={change_autosave_pref}/>\n            <br><br>\n            <p class=\"info\">\n                Join the home of the Lexicanter project on <a rel=\"noreferrer\" target=\"_blank\" href=\"https://discord.gg/uDk2XDhh8K\">Discord</a>\n            </p>\n            <p class=\"info\">\n                Support the continued developement of the app as a <a rel=\"noreferrer\" target=\"_blank\" href=\"https://patreon.com/saturnine_softworks\">patron</a>!\n            </p>\n            <br><br>\n            <p><u>New in 1.10</u></p>\n            <p style=\"width: 70%; margin: auto; text-align: left; line-height: 1.6\">\n                • Added three new themes: Pomegranate, Wisteria, and Terminal. <br>\n                • The word entry panel in the Lexicon tab is now collapsible. <br>\n                • The Phrasebook now has active overwrite protection to prevent you from deleting your work by mistake. <br>\n                • You can now search for an exact whole-word match in definitions and tags fields by using <code>!</code> as a prefix. <br>\n                • For HTML exports, the appearance on mobile devices has been improved. <br>\n                • Minor bug fixes for opening new windows from the File tab. <br>\n                • Lots of uner-the-hood changes for the app's appearance in preparation for future features.\n                <br><br>\n            </p>\n            <p><u>Patch 1.9.5</u></p>\n            <p style=\"width: 70%; margin: auto; text-align: left; line-height: 1.6\">\n                • Fixed a bug causing app-quit to be impossible sometimes. <br>\n                • Fixed some minor bugs with the styles. <br>\n                • Fixed a bug causing monospace toggle in the docs tab to be undoable. <br>\n                • Fixed a bug causing external hyperlinks not to use the preferred browser, and is some cases not open at all.\n            <br><br>\n            </p>\n            <p><u>Patch 1.9.4</u></p>\n            <p style=\"width: 70%; margin: auto; text-align: left; line-height: 1.6\">\n                • You can now hyperlink to entries in the lexicon. The link format is <code>lex::word</code>. <br>\n                • The documentation tab would previously not adjust to the width of the window. That has been fixed.\n            <br><br>\n            </p>\n            <p><u>New in 1.9</u></p>\n            <p style=\"width: 70%; margin: auto; text-align: left; line-height: 1.6\">\n                • Overhauled the Documentation tab, which now uses integrated <a href=\"https://editorjs.io/\" \n                    target=\"_blank\" rel=\"noreferrer\">EditorJS</a> technology. <br> Markdown is no longer supported in this tab, \n                    in favor of the new WYSIWYG style with a toolbar visible when you highlight text. <br>\n                • Note: The first time you load a file from an older version, there may be some formatting quirks. \n                    Most of these should sort themselves out after saving in the new version and re-loading. \n                    Please contact the developer if you run into persistent issues. <br>\n                • Fixed a bug with the Open New Window button which caused it to fail to open new windows. <br>\n                • The button to edit phrasebook entries has been change to right-click instead of left-click to\n                    make it more difficult to accidentally overwrite work in progress, and to allow for\n                    highlighting text. <br>\n                • An HTML Docs-Only export option has been added.\n            <br><br>\n            </p>\n            <p><u>Patch 1.8.14</u></p>\n            <p style=\"width: 70%; margin: auto; text-align: left; line-height: 1.6\">\n                • Fixed a few minor bugs with markdown parsing.<br>\n                • Added monospace markdown with <code>``this``</code> syntax.<br>\n                • Fixed a reported bug which affected the orthography testing area.\n            <br><br>\n            <p><u>New in 1.8</u></p>\n            <p style=\"width: 70%; margin: auto; text-align: left; line-height: 1.6\">\n                • File storage has been migrated to make auto-save possible. <br>\n                • Categories can now be defined and used in your Pronunciations rules. See the <a\n                    target=\"_blank\" href=\"https://lexicanter.com/docs\" rel=\"noreferrer\">docs page</a> for more info.<br>\n                • Five new color themes: Light, Marine, Glade, Leatherbound, and Purple Maar (contributed by <a\n                    target=\"_blank\" href=\"https://linktr.ee/maarzcreative\" rel=\"noreferrer\">Maarz</a>). <br>\n                • You can now load in your own custom CSS color themes.<br>\n                • Definitions, descriptions, and documentation sections now support simple <a target=\"_blank\"\n                    href=\"https://lexicanter.com/docs#markdown\" rel=\"noreferrer\">markdown</a>. <br>\n                • There's a new space in the Phonology tab to test your pronunciation rules. <br>\n                • Tag searches no longer require an exact match. <br>\n                • Several minor bug fixes, including one reported about tables being editable in the HTML\n                export.<br>\n            </p>\n            <br>\n        </div>\n    </div>\n</div>\n","<script lang=\"ts\">\n    const { ipcRenderer } = require('electron');\n\timport Lexicon from './components/Lexicon.svelte';\n\timport Phrasebook from './components/Phrasebook.svelte';\n\timport Phonology from './components/Phonology.svelte';\n    import Documentation from './components/Documentation.svelte';\n\timport File from './components/File.svelte';\n\timport Settings from './components/Settings.svelte';\n    import { theme, autosave } from './stores.js';\n    import { save_file } from './scripts/files.js';\n    import type { SvelteComponent } from 'svelte';\n    import type { SvelteComponentTyped } from 'svelte/types/runtime/internal/dev';\n\n    const tabs = [Lexicon, Phrasebook, Phonology, Documentation, File, Settings]\n    const tab_btns = ['Lexicon', 'Phrasebook', 'Phonology', 'Documentation', 'File', 'Settings'];\n    $: selectedTab = 0;\n\n    /**\n     * This block listens for the 'app-close' event, which is sent by the main\n     * process, and if the user has autosave enabled, saves the file before\n     * closing the app. If the user does not have autosave enabled, it prompts\n     * the user to confirm that they want to exit. The 'close' event is sent\n     * to the main process when app exit is confirmed. \n     */\n    ipcRenderer.on('app-close', _ => {\n        if ($autosave) {\n            save_file().then(_ => { ipcRenderer.send('close'); });\n        } else {\n            if ( window.confirm('You may have unsaved changes. Are you sure you want to exit?') )\n                ipcRenderer.send('close');\n        }\n    });\n</script>\n\n<link rel=\"stylesheet\" href=\"{$theme}\" />\n\n<body id=\"body\">\n    <div class='tab-container'>\n        <div class=\"button-container\">\n            <p class=\"version-info\"><i>v</i>2.0.0</p>\n            {#each tab_btns as tab, i}\n                <button on:click={() => selectedTab = i}\n                    class:selected={selectedTab === i} class='hover-highlight'>{tab}</button>\n            {/each}\n        </div>\n        {#each tabs as tab, i}\n            <div class:collapsed={selectedTab !== i}>\n                <svelte:component this={tab}/>\n            </div>\n        {/each}\n    </div>\n</body>\n","import App from './App.svelte';\nconst app = new App({\n    target: document.body,\n});\nexport default app;\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","subscribe","store","callbacks","unsub","unsubscribe","get_store_value","value","_","component_subscribe","component","callback","$$","on_destroy","push","set_store_value","ret","set","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","getAttribute","setAttribute","to_number","set_data","wholeText","set_input_value","input","set_style","key","important","style","removeProperty","setProperty","select_option","select","option","__value","selected","selectedIndex","toggle_class","toggle","classList","construct_svelte_component","props","current_component","set_current_component","createEventDispatcher","Error","get_current_component","type","detail","cancelable","bubbles","e","createEvent","initCustomEvent","custom_event","slice","call","defaultPrevented","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","add_flush_callback","seen_callbacks","Set","flushidx","flush","saved_component","update","pop","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","bind","index","undefined","bound","create_component","mount_component","customElement","m","new_on_destroy","on_mount","map","filter","destroy_component","make_dirty","then","fill","init","instance","create_fragment","not_equal","append_styles","parent_component","on_disconnect","context","Map","skip_bound","root","ready","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","$destroy","this","$on","indexOf","splice","$set","$$props","obj","$$set","keys","subscriber_queue","writable","start","stop","subscribers","new_value","run_queue","subscriber","invalidate","size","file_name","case_sensitive","ignore_diacritics","header_tags","lexicon","alphabet","word_input","word_pronunciation","phrasebook","phrase_input","phrase_pronunciation","phrase_description","category_input","selected_category","variant_inputs","romanizations","th","romans_input","onsets","medials","codas","vowels","illegals","Docs","theme","autosave","get_pronunciation","word","$romanizations","get","$case_sensitive","replaceAll","toLowerCase","lengths","rom","sort","substring","match","pattern","new_pattern","char","join","substitute","trim","writeRomans","categories","rules","split","line","rule","replace","includes","symbol","items_string","items","full_rule_set","expandedRules","substitution","uniqueCategorySymbols","combinations","reduce","combos","newCombos","combo","item","concat","newPattern","expandedSubstitution","expandedRule","generateRules","substituion","$lexicon","entry","$phrasebook","category","pronunciation","variant","variants","div","t","t_value","p0","p1","p2","t2","t2_value","t5","t5_value","dispatch","button0","button1","button","label","t0_value","t0","create_if_block_4","create_if_block_3","create_if_block_2","create_if_block_1","create_if_block","div13","div2","div0","label0","input0","div1","label1","input1","input2","div12","div5","div4","label2","input3","input4","br0","label3","textarea0","br1","label4","textarea1","br2","div3","div11","div8","div6","input5","div7","input6","div9","input7","div10","each_blocks","each_1_else","alphabetized","def_input","tags_input","search_words","search_definitions","search_tags","edit_entry","confirmation","$word_input","confirm","$word_pronunciation","$$invalidate","assign","console","log","add_word","definition","tags","filtered_lex","acc","priority_tags","$alphabet","$ignore_diacritics","all_words","structuredClone","tag_ordered_lexes","tag","w","remaining_words","order","find_in_order","final_sort","group","lex","list","normalize","token","RegExp","j","sorted","alphabetize","collapsedPanel","words_search","definitions_search","tags_search","test","partial_tag_match","needs_exact_match","has_exact_match","checked","each_value","Math","ceil","description","t4","t4_value","phrase","textarea","br","show_if","hr","button2","each0_else","each1_else","$category_input","$selected_category","search_phrase","search_description","phrase_keys","edit_phrase","$phrase_input","$phrase_pronunciation","$phrase_description","$variant_inputs","scope","phrase_search","descript_search","phrase_match","descript_match","search_book","new_phrase","window","textarea2","textarea3","br3","textarea4","br4","br5","label5","br6","br7","label6","textarea5","br8","br9","label7","textarea6","textarea7","trial","ortho_test","trial_completion","random_boolean","floor","random","choice","arr","inventory","Onsets","Medials","Codas","Vowels","Illegals","finalize","some","v","ends_in_vowel","lastIndexOf","complete_word","test_pronunciation","generated_words","$onsets","$medials","$codas","$vowels","$illegals","attempt","generate_word","$romans_input","EditorJS","require","Header","Paragraph","Table","Underline","Monospace","CSS","constructor","api","iconClasses","base","styles","inlineToolButton","active","inlineToolButtonActive","isInline","render","textContent","surround","range","termWrapper","selection","findParentTag","unwrap","wrap","extractContents","insertNode","expandToTag","sel","getSelection","getRangeAt","unwrappedContent","removeAllRanges","addRange","checkState","termTag","sanitize","code","class","initialize_docs","config","holder","tools","underline","monospace","header","inlineToolbar","paragraph","placeholder","table","rows","cols","withHeadings","ipcRenderer","fs","path","async","userData","invoke","result","collect_export_data","return_blob","documentation","save","arrayify","exports","export_data","Version","Lexicon","Alphabet","Phrasebook","Phonotactics","Romanization","HeaderTags","IgnoreDiacritics","CaseSensitive","Blob","JSON","stringify","editorjs_to_html","container","blocks","level","innerHTML","tbody","content","row","tr","cell","td","save_file","prompt","blob","user_path","existsSync","sep","mkdirSync","writeFileSync","Notification","alert","err","saveAs","file_handle","showSaveFilePicker","suggestedName","f","requestPermission","mode","file","createWritable","write","close","arr_data","String","all","export_container","head","scripts","alphabet_input","readFileSync","dirname","__dirname","theme_select","overrides","body","outerHTML","docs","padding","openLegacy","contents","Initial","Middle","Final","Vowel","Illegal","destroy","div17","div16","div15","button3","p3","p4","button4","p5","button5","p6","p7","button6","button7","button8","button9","button10","p8","div14","button11","csv_headers","csv_words","csv_definitions","old_pattern","read_contents","loading_message","$header_tags","docs_data","$Docs","dialog","params","showOpenDialog","title","defaultPath","properties","file_path","querySelectorAll","planet","animationPlayState","setTimeout","readFile","parse","$file_name","basename","mkdir","showOpenFilePicker","getFile","string_contents","open","headers","words","definitions","columns","import_csv","optgroup0","option0","option1","optgroup1","option2","option3","option4","option5","option6","optgroup2","option7","option8","p9","p10","p11","p12","p13","p14","p15","br44","theme_value","toString","$theme","$autosave","writeFile","theme_path","themes_dir","autosave_tracker","setInterval","clearInterval","selected_option","querySelector","select_value","link","tabs","Phonology","Documentation","File","Settings","on","send","selectedTab"],"mappings":"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"}