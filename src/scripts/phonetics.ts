// TODO: The pronunciation rule format is going to be changed to the more standard `pattern/substitution/context` format. This whole function needs to be rewritten.
import { get } from 'svelte/store';
import { 
    Language, pronunciationRules, wordInput, wordPronunciation, phraseInput, phrasePronunciation 
} from '../stores.js';
import type * as Lexc from './types';
const Lang = () => get(Language);

/**
 * Takes a word and returns its pronunciation based on
 * the user-defined romanization rules.
 * @param {string} word
 * @returns {string}
 */
export function get_pronunciation(word: string) {
    // TODO: Rewrite most of this code for readability; it currently requires a lot of comments to understand.
    let $romanizations = get(pronunciationRules);
    let caseSensitive = Lang().CaseSensitive;
    word = `^${word.replaceAll(/[^\S\n]|(\n)/gm, '^$1')}^`; // add carets for front/end searching, treat spaces as word boundaries
    word = caseSensitive? word : word.toLowerCase(); // if the case-sensitive setting is ticked, don't force to lowercase.
    // Romanizations need to be sorted by length and applied in that order.
    // First, we need an array of all the differnt lengths of polygraphs which are used in the romanizations.
    let lengths: number[] = [];
    for (let rom in $romanizations) {
        lengths.push(rom.length);
    }
    lengths = Array.from(new Set(lengths)).sort((a, b) => b - a); // descending order, unique. It just works.

    // We then create a dictionary with all of these lengths as keys.
    // For each length key, its value is set to a dictionary of romanizations, such that `sort` is formatted like
    // {
    //  1: { '1 character pattern': 'pronunciation', 'another 1 character pattern': 'pronunciation', ... },
    //  2: { '2 character pattern': 'pronunciation', ... }
    //  ...
    // }
    
    let sort: { [index: number]: { [index: string]: string; } } = {};
    for (let length of lengths) {
        if (!(length in sort)) {
            sort[length] = {};
        }
        for (let romRules in $romanizations) {
            for (let romLect in $romanizations[romRules]) {
                for (let rom of $romanizations[romRules][romLect]) {
                    if (rom.length === length) {
                        sort[length][rom] = $romanizations[romRules][romLect][rom];
                    }
                }
            }
        }
    }

    /** 
     * Then we go through each length of pattern, checking for patterns from the starting point of each
     * character in the word. Given the word 'dread' and the pattern 'ad', it would find a pattern match
     * when i = 3 and the patterns length we're checking for is 2 (†1). We then find the pronunciation to
     * substitute at this position (†2) and use slices to replace the pattern with the substitute (†3).
     * We add the length of the substituion string to `i` so that the next iteration skips past the part of
     * the word we have already changed (†4). When this process is done, we remove the carets (†5) and
     * return the processed word. 
     */
    for (let i = 0; i < word.length; i++) {
        for (let length of lengths) {
            let substring: string = word.slice(i, i + length);

            let match: boolean | string = false;
            Object.keys(sort[length]).forEach(pattern => {
                let new_pattern = [...pattern]
                    .map((char, i) => {
                        return char === '_' && substring[i] !== '^'? substring[i] : char;
                    })
                    .join('');
                if (new_pattern === substring) {
                    match = [...sort[length][pattern]]
                        .map((char, i) => {
                            return char === '_' && substring[i] !== '^'? substring[i] : char;
                        })
                        .join('');
                }
            });

            if (substring in sort[length] || match) { // †1
                let substitute = match ? match : sort[length][substring]; // †2
                word = word.slice(0, i) + substitute + word.slice(length + i); // †3
                i += substitute.length - 1; // †4
                break;
            }
        }
    }
    return word.replaceAll('^', ' ').trim().replaceAll('∅', ''); // (†5)
}

/**
 * Takes a list of rules and a dictionary of categories and returns a new list of rules
 * which have been permutated with every item from the categories for every rule that
 * contains a category symbol.
 * @param {Array} rules
 * @param {Object} categories
 * @returns {Array} The expanded rules array.
 */ //TODO: Like most of the arrays and dictionaries in this codebase, new interfaces should be created (TS migration).
function generateRules(rules: string[], categories) {
    // This function was mostly generated by OpenAI's chatGPT @ https://chat.openai.com/chat.

    // Initialize an empty array to store the expanded rules
    let expandedRules = [];

    // Iterate through each rule
    for (let rule of rules) {
        // Split the rule into pattern and substitution parts
        let [pattern, substitution] = rule.split('>');

        // Split the pattern and substitution into arrays of characters
        let patternArray = pattern.split('');
        let substitutionArray = substitution.split('');

        // Create a new set of unique category symbols in the pattern
        let uniqueCategorySymbols = [
            ...new Set<string>(patternArray.filter((symbol: string) => symbol in categories)),
        ];

        // Create all possible combinations of the unique category symbols.
        let combinations = uniqueCategorySymbols.reduce(
            (combos, symbol) => {
                let newCombos = [];
                for (let combo of combos) {
                    for (let item of categories[symbol]) {
                        newCombos.push(combo.concat(item));
                    }
                }
                return newCombos;
            },
            [[]]
        );

        // Iterate through the combinations of symbols
        for (let combo of combinations) {
            let newPattern = [...patternArray];
            let expandedSubstitution = [...substitutionArray];

            // Replace the category symbols in the pattern and substitution with the corresponding symbol in the combination
            for (let i = 0; i < uniqueCategorySymbols.length; i++) {
                newPattern = newPattern.map(symbol =>
                    symbol === uniqueCategorySymbols[i] ? combo[i] : symbol
                );
            }

            // GPT couldn't figure out how to do this block. Have to do this myself. If there are bugs, they're probably here.
            expandedSubstitution = expandedSubstitution.map((symbol, index) => {
                if (uniqueCategorySymbols.includes(symbol)) {
                    // symbol is in pattern
                    return combo[uniqueCategorySymbols.indexOf(symbol)];
                } else if (symbol in categories) {
                    // symbol is not in pattern
                    return categories[symbol][
                        categories[[...patternArray][index]].indexOf(
                            newPattern[index]
                        )
                    ];
                } else {
                    return symbol;
                } // symbol is not a category
            });

            // generate the new rule by joining pattern and substitution and push into expandedRules
            let expandedRule = `${newPattern.join('')}>${expandedSubstitution.join('')}`;
            // expandedRule = expandedRule.replaceAll('∅', ''); // get rid of null signs // leave null signs, post-processor takes care of it
            expandedRules.push(expandedRule);
        }
    }
    // Return the expanded rules array
    return expandedRules;
}

/**
 * Updates the romanizations object with the new rules. Uses {@link generateRules}
 * to deal with category symbol parsing. It updates the pronunciations of all
 * entries in the lexicon and phrasebook, provided they are not marked as
 * irregular.
 */
export function writeRomans () {
    let $romanizations = {};
    let categories = {};
    let rules = [];

    // On a first pass of the input directly in the textarea,
    // we parse out the category definitions and rom rules.
    // TODO: For now this just uses the default General dialect.
    let txt: string = Lang().Pronunciations.General;
    txt.split('\n').forEach(line => {
        // Parse each new line as a rule
        // remove all white space
        let rule = line.trim().replace(/\s+/g, '');
        // if the rule contain `::`, it is a category
        if (rule.includes('::')) {
            let [symbol, items_string] = rule.split('::');
            let items = items_string.split(',');
            categories[symbol] = items;
        }
        // if the rule contain `>`, it is a rom rule
        if (rule.includes('>')) {
            rules.push(rule);
        }
    });

    // Then we let GPT solve all my problems.
    let full_rule_set = generateRules(rules, categories);

    // And now we just have to parse the rules to the romanizations dict.
    full_rule_set.forEach(rule => {
        let [pattern, substituion] = rule.split('>');
        $romanizations[pattern] = substituion;
    });

    // The block below is used to update all the pronunciation values in the editors, lexicon, and phrasebook.
    wordPronunciation.set(get_pronunciation(get(wordInput)));
    let lexicon: Lexc.Lexicon = Lang().Lexicon;
    for (let word in lexicon) {
        // TODO: Check pronunciations of all dialects
        if (lexicon[word].pronunciations.General.irregular === false) {
            // all non-irrelgular pronunciations
            lexicon[word].pronunciations.General.ipa = get_pronunciation(word);
        }
    }
    Lang().Lexicon = lexicon;

    phrasePronunciation.set(get_pronunciation(get(phraseInput)));
    let phrasebook: Lexc.Phrasebook = Lang().Phrasebook;
    for (let category in phrasebook) {
        for (let entry in phrasebook[category]) {
            // TODO: Check pronunciations of all dialects
            phrasebook[category][entry].pronunciations.General.ipa =
                get_pronunciation(entry);
            for (let variant in phrasebook[category][entry].variants) {
                phrasebook[category][entry].variants[variant].pronunciations.General.ipa =
                    get_pronunciation(variant);
            }
        }
    }
    Lang().Phrasebook = phrasebook;

    pronunciationRules.set($romanizations);
};

/**
 * Attempts to complete a given word using the user's phonotactics.
 * @param {string} trial
 * @returns {string} The completed word, or an empty string if no word could be generated
 */
export function complete_word(trial) {
    let random_boolean = () => Math.floor(Math.random() * 2) === 0;
    let choice = arr => arr[Math.floor(Math.random() * arr.length)];
    let inventory = {
        Onsets: Lang().Phonotactics.General.Onsets,
        Medials: Lang().Phonotactics.General.Medials, 
        Codas: Lang().Phonotactics.General.Codas,
        Vowels: Lang().Phonotactics.General.Vowels,
        Illegals: Lang().Phonotactics.General.Illegals? Lang().Phonotactics.General.Illegals : []
    }
    let word = '^' + trial;

    const finalize = (word) => {
        word += '^'; // the string is in the format "^word^" so that "^" 
                    // may be be used as a character to mark the start/end of a word
                   // in the user-defined illegal combinations
        if (!inventory.Illegals.some(v => word.includes(v))) {
            return word.replace(/\^/g, '');
        } else {
            return '';
        }
    };

    let ends_in_vowel = false;
    for (let v of inventory.Vowels) {
        // Check if word ends in vowel; add middle consonant and vowel, or coda and end
        if (
            word.includes(v) &&
            word.lastIndexOf(v) === word.length - v.length
        ) {
            if (random_boolean()) {
                word += choice(inventory.Medials) + choice(inventory.Vowels);
                ends_in_vowel = true;
                break;
            } else {
                word += choice(inventory.Codas);
                return finalize(word);
            }
        }
    }
    if (!ends_in_vowel) {
        // Add vowel to end of word, potentially end word with vowel or vowel + coda
        word += choice(inventory.Vowels);
        if (random_boolean()) {
            if (random_boolean()) {
                word += choice(inventory.Codas);
            }
            return finalize(word);
        }
    }
    // End word with one of: coda, middle + vowel, or middle + vowel + coda
    if (random_boolean()) {
        word += choice(inventory.Codas);
    } else {
        word += choice(inventory.Medials) + choice(inventory.Vowels);
        if (random_boolean()) {
            word += choice(inventory.Codas);
        }
    }
    return finalize(word);
}

/**
 * Generates a random word based on the given phonotactics. Will attempt
 * up to 50 times to generate a word that does not contain any illegal
 * combinations. If no word can be generated, returns an empty string.
 * @returns {string} The generated word, or an empty string if one could not be generated.
 */
export function generate_word() {
    const attempt = () => {
        let inventory = {
            Onsets: Lang().Phonotactics.General.Onsets,
            Medials: Lang().Phonotactics.General.Medials,
            Codas: Lang().Phonotactics.General.Codas,
            Vowels: Lang().Phonotactics.General.Vowels,
            Illegals: Lang().Phonotactics.General.Illegals? Lang().Phonotactics.General.Illegals : []
        }
        let random_boolean = () => Math.floor(Math.random() * 2) === 0;
        let choice = arr => arr[Math.floor(Math.random() * arr.length)];
        let word = '^';
    
        if (random_boolean()) {
            word += choice(inventory.Vowels);
        } else {
            word += choice(inventory.Onsets);
            word += choice(inventory.Vowels);
        }
    
        for (let j = 0; j < 2; j++) {
            if (random_boolean() || word.length === 2 /* word is "^vowel" */) {
                word += choice(inventory.Medials);
                word += choice(inventory.Vowels);
            }
        }
        if (random_boolean()) {
            word += choice(inventory.Codas);
        }
    
        word += '^';
        if (!inventory.Illegals.some(v => word.includes(v))) {
            return word.replace(/\^/g, '');
        } else {
            return '';
        }
    }
    for (let i = 0; i < 50; i++) {
        let word = attempt();
        if (!!word) {
            return word;
        }
    }
    return '';
}
